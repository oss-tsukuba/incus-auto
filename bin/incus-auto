#!/usr/bin/env python3

# Requirements:
# --- for Debian,Ubuntu series ---
# apt-get install python3 python3-docopt python3-schema python3-yaml
#
# --- for RHEL,CentOS series ---
# yum install     epel-release
# yum install     python3 python3-docopt python3-schema python3-pyyaml
#
# --- Or, install to ~/.local just for user's environment ---
# (required: python3-pip)
# pip3 install --user docopt schema PyYAML
#
# Coding style check:
# flake8 ./incus-auto

import os
import logging
import subprocess
import json
from pprint import pformat
from io import StringIO
import time
import inspect
import shlex

from docopt import docopt
from schema import Schema, Or
import yaml

program_name = os.path.basename(__file__)

# TODO   {f} exec <name> <args>... [options]
# TODO   {f} shell <name> [options]

__doc__ = """
Automating deployment system by Incus or LXD.

Usage:
  {f} init [options]
  {f} destroy [options]
  {f} ls [options]
  {f} ps [options]
  {f} config [options]
  {f} <command> <name>... [options]
  {f} <command> --all [options]

Options:
  -a, --all                 all buildimages or all hosts
  -b, --buildimage          control buildimages
  -f, --file=FILE           configuration file (YAML)
                            [default: incus-auto.yaml]
  -o, --override=FILE       override configuration file (if it exists)
                            [default: incus-auto.override.yaml]
  -l, --loglevel=LEVEL      log level (debug, info, warning, error)
                            [default: info]
  --encoding=CODEC          codec for filename encoding
          (https://docs.python.org/3/library/codecs.html#standard-encodings)
                            [default: utf-8]
  -?, -h, --help            show this help and exit

Command:
  init       initialize networks, profiles and buildimages
  destroy    destroy buildimages, profiles and networks
  build      (re)build images
  launch     launch hosts
  ps         list status of hosts
  ls         list hosts by `incus list` command
  config     check and show configuration parameters
  stop       stop hosts
  start      start hosts
  restart    restart hosts
  delete     delete stopped hosts, profile and network
""".format(f=program_name)

opt_schema = Schema({
    '--all': bool,
    '--buildimage': bool,
    '--file': str,
    '--override': str,
    '--loglevel': str,
    '--encoding': str,
    '--help': bool,
    '<command>': Or(str, None),
    'init': bool,
    'destroy': bool,
    'ls': bool,
    'ps': bool,
    'config': bool,
    '<name>': [str],
})


class CUI():
    def cui_init(self, program_name):
        self.program_name = program_name
        self._docopt = docopt(self.get_doc())
        self.opt = self.get_opt_schema().validate(self._docopt)
        self.loglevel_str = self.opt['--loglevel']

        loglevel_dict = {
            'debug': logging.DEBUG,
            'info': logging.INFO,
            'warning': logging.WARNING,
            'error': logging.ERROR,
        }
        self.loglevel = loglevel_dict[self.loglevel_str.lower()]
        # use stderr
        self.logger = self.logger_init()

    def logger_init(self):
        logger = logging.getLogger()  # RootLogger
        logger.setLevel(self.loglevel)
        stream = logging.StreamHandler()  # stderr
        if self.loglevel == logging.DEBUG:
            fmt = '%(filename)s:%(levelname)s:L%(lineno)d:' + \
                '%(asctime)s: %(message)s'
            fmt = fmt.format(self.program_name)
        elif self.loglevel == logging.INFO:
            fmt = '{}: %(message)s'.format(self.program_name)
        else:
            fmt = '%(message)s'
        formatter_stream = logging.Formatter(fmt=fmt, datefmt='%Y%m%d%H%M%S')
        stream.setFormatter(formatter_stream)
        stream.setLevel(self.loglevel)
        logger.addHandler(stream)
        return logger

    def get_doc(self):
        raise NotImplementedError

    def get_opt_chema(self):
        raise NotImplementedError

    def run(self):
        raise NotImplementedError

    def execv(self, args, input=None, output=None,
              timeout=None, textmode=False, ignore_error=False):
        if isinstance(args, str):
            # ex. shlex.split('a b "c d" \\"e')
            #     -> ['a', 'b', 'c d', '"e']
            args = shlex.split(args)
        out, err, ret = self.execv_raw(args, input, output, timeout, textmode)
        if textmode:
            err = err.rstrip()
        else:
            try:
                err = err.decode().rstrip()
            except Exception:
                self.logger.debug('cannot decode: err=%s', err)
        if ret != 0:
            msg = f'{str(args)}: {str(err)}'
            if ignore_error:
                self.logger.info('Error ignored: ' + msg)
                return
            else:
                raise Exception('Error: ' + msg)
        if err:
            self.logger.info(err)
        self.logger.debug(f'Success: {str(args)}')
        return out

    def execv_raw(self, args, input=None, output=None,
                  timeout=None, textmode=False):
        # input: read()able stream or None
        # output:
        #   True: use PIPE (return out, err)
        #   False: disable
        #   None: write to stdout and stderr directly
        if textmode:
            encoding = self.encoding
        else:
            encoding = None
        if input is not None:
            stdin = subprocess.PIPE
        else:
            stdin = subprocess.DEVNULL
        if output is None:
            stdout = None
        elif output:
            stdout = subprocess.PIPE
        else:
            stdout = subprocess.DEVNULL
        # self.logger.debug('Popen(args=%s)', str(args))
        proc = subprocess.Popen(
            args, shell=False, encoding=encoding, close_fds=True,
            stdin=stdin, stdout=stdout, stderr=stdout)
        try:
            if input is not None:
                out, err = proc.communicate(input.read(), timeout=timeout)
            else:
                out, err = proc.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            proc.kill()
            out, err = proc.communicate()
        ret = proc.wait()
        if out is None:
            out = ''
        if err is None:
            err = ''
        return out, err, ret

    @classmethod
    def dictpath(cls, d, dpath):
        if isinstance(dpath, list):
            keys = dpath
        else:
            keys = [key for key in dpath.split('/') if key]
        result = d
        for key in keys:
            try:
                result = result[key]
            except (KeyError, TypeError):
                return None
        return result

    @classmethod
    def tobool(cls, s):
        if isinstance(s, bool):
            return s
        return s.lower() in ['true', 'yes', 'on', 'enable']


class IncusAuto(CUI):
    def __init__(self, program_name):
        self.cui_init(program_name)
        self.parse_opt()
        self.change_dir()
        self.load_conf()
        self.check_required()

    def get_doc(self):
        return __doc__

    def get_opt_schema(self):
        return opt_schema

    def parse_opt(self):
        self.names = self.opt['<name>']
        self.use_all = self.opt['--all']
        self.control_buildimage = self.opt['--buildimage']
        self.conf_file = self.opt['--file']
        self.override_file = self.opt['--override']
        self.encoding = self.opt['--encoding']

    def change_dir(self):
        self.basedir = os.path.realpath(os.path.dirname(self.conf_file))
        os.chdir(self.basedir)

    @classmethod
    def deep_update(cls, dst, src, override=False):
        def update_common(target, key, val):
            target_val = target.get(key, None)
            if isinstance(val, dict):
                if target_val is None:
                    target[key] = {}
                cls.deep_update(target[key], val, override)
            elif override or target_val is None:
                target[key] = val

        for k, v in src.items():
            if k == '__ANY__':
                for k2 in list(dst.keys()):
                    update_common(dst, k2, v)
            else:
                update_common(dst, k, v)

    def pformat(self, obj):
        if not hasattr(self, '_pformat_has_sort_dicts'):
            pformat_kwargs = inspect.getfullargspec(pformat).kwonlyargs
            self.logger.debug(f'pformat_kwargs={str(pformat_kwargs)}')
            # NOTE: Changed in Python 3.8: Added the sort_dicts parameter.
            if 'sort_dicts' in pformat_kwargs:
                self._pformat_has_sort_dicts = True
            else:
                self._pformat_has_sort_dicts = False
        if self._pformat_has_sort_dicts:
            return pformat(obj, sort_dicts=False)
        else:
            return pformat(obj)

    def load_conf(self):
        self.logger.debug(self.pformat(self.opt))
        with open(self.conf_file) as f:
            self.conf_dict = yaml.safe_load(f)
        self.logger.debug(self.conf_file + ' (original): '
                          + self.pformat(self.conf_dict))
        if os.path.exists(self.override_file):
            with open(self.override_file) as f:
                override_dict = yaml.safe_load(f)
                self.deep_update(self.conf_dict, override_dict, override=True)
            self.logger.debug(self.override_file + ' (override): '
                              + self.pformat(self.conf_dict))

        # TODO set defaults
        config_defaults = {
            'config': {
                'incus_command': 'incus',
                'idmap': False,
                'user': 'incus',  # main guest user
                'uid': 2000,
                'ssh_authorized_keys': 'ssh_authorized_keys',
            },
            'buildimage': {
                '__ANY__': {
                    'vm': False,
                    'devices': {
                        'root': {
                            'size': '5GB',
                        },
                    },
                },
            },
            'host': {
                '__ANY__': {
                    'vm': False,
                    'devices': {
                        'root': {
                            'size': '5GB',
                        },
                    },
                },
            },
        }
        self.deep_update(self.conf_dict, config_defaults)
        self.logger.debug('self.conf_dict (set defaults): '
                          + self.pformat(self.conf_dict))

        for name in self.conf('/buildimage').keys():
            if self.is_defined(name, '/host'):
                raise Exception(
                    'Error: buildimage and host cannot be duplicated: ' + name)
        self.project_prefix = self.conf('/config/project') + '-'
        self.incus_command = self.conf('/config/incus_command')
        self.stop_timeout = 60

    def check_required(self):
        self.authorized_keys = self.convert_fullpath(
            self.conf('/config/ssh_authorized_keys'))
        if not os.access(self.authorized_keys, os.R_OK):
            raise Exception(f'Error: cannot read: {self.authorized_keys}')

    def conf(self, confpath):
        return self.dictpath(self.conf_dict, confpath)

    def name_iter(self):
        if self.control_buildimage:
            target_path = '/buildimage'
        else:
            target_path = '/host'
        d = self.conf(target_path)
        if self.use_all:
            for name in d.keys():
                yield (name, self.project_prefix + name, d[name])
        else:  # specified hosts
            for name in self.names:
                self.check_defined(name, target_path)
                yield (name, self.project_prefix + name, d[name])

    def is_defined(self, name, dpath):
        return name in self.conf(dpath).keys()

    def check_defined(self, name, dpath):
        if not self.is_defined(name, dpath):
            raise Exception(f'Undefined {dpath}: {name}')

    def incus(self, args, input=None, output=None, ignore_error=False):
        if isinstance(args, str):
            args = shlex.split(args)
        args = [self.incus_command] + args
        return self.execv(args, textmode=True, input=input, output=output,
                          ignore_error=ignore_error)

    def incus_exec(self, fullname, args,
                   input=None, output=None, ignore_error=False):
        if isinstance(args, str):
            args = shlex.split(args)
        return self.incus(['exec', fullname, '--'] + args,
                          input=input, output=output,
                          ignore_error=ignore_error)

    def incus_ls_json(self):
        j_str = self.incus('ls -f json', output=True)
        return json.loads(j_str)

    def incus_is_running(self, name):
        try:
            self.incus(['exec', name, 'hostname'])
            return True
        except Exception:
            return False

    def convert_net_if(self, net_if, info):
        if not self.tobool(info['vm']):
            return net_if
        table = {
            'eth0': 'enp5s0',
            'eth1': 'enp6s0',
        }
        return table[net_if]

    def incus_wait_for_wakeup(self, name, info):
        net_if = self.convert_net_if('eth0', info)
        while not self.incus_is_running(name):
            self.logger.info(f'Waiting for startup: {name}')
            time.sleep(1)
        while self.incus_get_ipv4(name, net_if) is None:
            self.logger.info(f'Waiting until seeing IP address: {name}')
            time.sleep(1)

    def incus_get_ipv4(self, name, net_if):
        for hostinfo in self.incus_ls_json():
            if name != hostinfo['name']:
                continue
            addresses = self.dictpath(
                hostinfo, ['state', 'network', net_if, 'addresses'])
            if addresses is None:
                break
            for a in addresses:
                if a.get('family') == 'inet' \
                   and a.get('address', None) is not None:
                    return a['address']
            break
        return None

    def convert_fullpath(self, path):
        if path is None:
            return None
        if path.startswith('/'):
            return path
        return os.path.join(self.basedir, path)

    def convert_disk_source(self, devices):
        for device, params in devices.items():
            if params.get('type') == 'disk':
                source = params.get('source', None)
                fullpath = self.convert_fullpath(source)
                if fullpath is not None:
                    self.logger.debug("source: fullpath=" + str(fullpath))
                    devices[device]['source'] = fullpath
        return devices

    def incus_each(self, cmd, args=[], build=False, ignore_error=False):
        if build:
            self.control_buildimage = build
        for name, fullname, info in self.name_iter():
            print(f'{self.incus_command} {cmd} {fullname}')
            self.incus([cmd, fullname] + args,
                       ignore_error=ignore_error,
                       output=True)  # err in Exception

    def main(self):
        commands = {
            'init': self.cmd_init,
            'destroy': self.cmd_destroy,
            'ls': self.cmd_ls,
            'ps': self.cmd_ps,
            'config': self.cmd_config,
            'build': self.cmd_build,
            'launch': self.cmd_launch,
            'start': self.cmd_start,
            'restart': self.cmd_restart,
            'stop': self.cmd_stop,
            'delete': self.cmd_delete,
        }
        simple_commands = ['init', 'destroy', 'ls', 'ps', 'config']
        cmd_name = None
        for n in simple_commands:
            if self.opt[n]:
                cmd_name = n
                break
        if cmd_name is None:
            cmd_name = self.opt['<command>']
        # execute method
        commands[cmd_name]()

    def cmd_config(self):
        print(yaml.dump(self.conf_dict, sort_keys=False))

    def cmd_init(self):
        # create networks
        for netname in self.conf('/config/network').keys():
            self.incus(f'network create {netname}')
            d = self.conf(['config', 'network', netname])
            ystr = yaml.dump(d, sort_keys=False)
            self.logger.debug(ystr)
            str_input = StringIO(ystr)
            self.incus(f'network edit {netname}', input=str_input)
            self.logger.info(f'network: "{netname}" created')
            self.incus(f'network show {netname}')
        # create profiles
        for profname in self.conf('/config/profile').keys():
            fullname = self.project_prefix + profname
            self.incus(f'profile create {fullname}')
            d = self.conf(['config', 'profile', profname])
            devices = d.get('devices', None)
            if devices is not None:
                d['devices'] = self.convert_disk_source(devices)
            ystr = yaml.dump(d, sort_keys=False)
            self.logger.debug(ystr)
            str_input = StringIO(ystr)
            self.incus(f'profile edit {fullname}', input=str_input)
            self.logger.info(f'profile: "{fullname}" created')
            self.incus(f'profile show {fullname}')
        # create buildimages
        self.use_all = True
        self.cmd_build()

    def cmd_destroy(self):
        # delete buildimages
        self.use_all = True
        # self.incus_each('stop', ['-f'], build=True, ignore_error=True)
        self.incus_each('delete', ['-f'], build=True, ignore_error=True)
        # delete profiles
        for profname in self.conf('/config/profile').keys():
            fullname = self.project_prefix + profname
            self.incus(f'profile delete {fullname}', ignore_error=True,
                       output=True)
        # delete networks
        for netname in self.conf('/config/network').keys():
            self.incus(f'network delete {netname}', ignore_error=True,
                       output=True)

    def cmd_start(self):
        self.incus_each('start', ['--verbose'],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_restart(self):
        self.incus_each('restart', ['--verbose', '--timeout', str(self.stop_timeout)],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_stop(self):
        self.incus_each('stop', ['--verbose', '--timeout', str(self.stop_timeout)],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_delete(self):
        self.incus_each('delete', ['--verbose'],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_ls(self):
        if self.use_all or len(self.names) == 0:
            print(self.incus(f'ls -c ns4t {self.project_prefix}'))
        else:
            for name in self.name_iter():
                print(self.incus(f'ls -c ns4t {self.project_prefix}{name}$'))

    def cmd_ps(self):
        if len(self.names) == 0:
            self.use_all = True
        names = self.name_iter()

        state_dict = {}
        fullname_max = 0
        state_max = 0
        host_dict = {}
        for hostinfo in self.incus_ls_json():
            host_dict[hostinfo['name']] = hostinfo
        for name, fullname, info in names:
            hostinfo = host_dict.get(fullname, None)
            if hostinfo is None:
                state = "NOTCREATED"
            else:
                state = hostinfo['config']['volatile.last_state.power']
            state_dict[fullname] = state
            fullname_len = len(fullname)
            if fullname_len > fullname_max:
                fullname_max = fullname_len
            state_len = len(state)
            if state_len > state_max:
                state_max = state_len
        for fullname, state in state_dict.items():
            print(f'{fullname:<{fullname_max}}  {state:<{fullname_max}}')

    def incus_launch(self, info, name, fullname):
        image = info['image']
        args = ['launch', image, fullname]
        for p in info.get('profile', {}):
            args += ['-p', self.project_prefix + p]
        for devname, params in info.get('devices', {}).items():
            kvlist = [devname]
            for key, val in params.items():
                kvlist.append(key + '=' + str(val))
            val = ','.join(kvlist)
            args += ['-d', val]

        ### NOT WORK: Error: Cannot override config for device "VOLUME_0":
        ### Device not found in profile devices
        # volume_list = info.get('volume', None)
        # if volume_list is not None:
        #     # /host|buildimage/NAME/volume : SRC:DST
        #     #   -> -d DEVNAME,type=disk,source=SRC,path=DST
        #     count = 0
        #     for volume_map in volume_list:
        #         device_name = f'VOLUME_{count}'
        #         kvlist = [device_name]
        #         v = volume_map.split(':')  # TODO support "SRC":"DST" ?
        #         src = self.convert_fullpath(v[0])
        #         dst = v[1]
        #         val = f'{device_name},type=disk,source={src},path={dst}'
        #         args += ['-d', val]
        #         count += 1

        for key, val in info.get('config', {}).items():
            args += ['-c', key + '=' + str(val)]
        idmap = self.conf('/config/idmap')
        idmap_uid = None
        self.logger.debug(f'idmap={idmap}')
        if str(idmap).isdigit():
            idmap_uid = str(idmap)
        elif self.tobool(idmap):
            idmap_uid = str(os.getuid())
        if idmap_uid is not None:
            args += ['-c', f'raw.idmap=both {idmap_uid} 0']

        if self.tobool(info['vm']):
            args += ['--vm']
        else:  # container
            args += ['-c', 'security.nesting=true']
        self.incus(args)

    def mount_volume(self, fullname, info):
        volume_list = info.get('volume', None)
        if volume_list is None:
            return
        # /host|buildimage/NAME/volume : SRC:DST
        #   -> -d DEVNAME,type=disk,source=SRC,path=DST
        count = 0
        for volume_map in volume_list:
            device_name = f'VOLUME_{count}'
            kvlist = [device_name]
            v = volume_map.split(':')  # TODO support "SRC":"DST" ?
            src = self.convert_fullpath(v[0])
            dst = v[1]
            self.incus(['config', 'device', 'add', fullname,
                        device_name, 'disk', f'source={src}', f'path={dst}'])
            count += 1

    def growpart(self, fullname):
        self.incus_exec(fullname,
                        'yum install -y e2fsprogs cloud-utils-growpart gdisk')
        mount = self.incus_exec(fullname, 'mount', output=True)
        device = None
        for line in mount.splitlines():
            fields = line.strip().split()
            if len(fields) >= 3 and fields[2] == "/":
                device = fields[0]
                break
        if device is not None:
            prefix = device.rstrip('0123456789')
            suffix = device[len(prefix):]
            self.incus_exec(fullname, f'growpart {prefix} {suffix}',
                            ignore_error=True)
            self.incus_exec(fullname, f'resize2fs {device}',
                            ignore_error=True)
            self.incus_exec(fullname, 'df -h')

    def setup_user_and_ssh(self, info, fullname):
        user = self.conf('/config/user')
        uid = self.conf('/config/uid')
        # ignore: useradd: user 'incus' already exists
        self.incus_exec(fullname, 'useradd --create-home --shell /bin/bash'
                        + f' --uid {uid} {user}', ignore_error=True)
        homedir = self.incus_exec(fullname,
                                  ['su', user, 'sh', '-c',
                                   'echo $HOME'],
                                  output=True).strip()
        # sshdir=f'/home/{user}/.ssh'
        sshdir = homedir + '/.ssh'
        self.incus_exec(fullname, f'mkdir -p {sshdir}')
        # file copy
        self.incus(['file', 'push', self.authorized_keys,
                    fullname + sshdir + '/authorized_keys'])
        self.incus_exec(fullname, f'chown -R {user}:{user} {sshdir}')
        self.incus_exec(fullname, f'chmod 700 {sshdir}')
        self.incus_exec(fullname, f'chmod 600 {sshdir}/authorized_keys')

        if info['series'] == 'rhel':
            self.incus_exec(fullname, f'usermod -a -G wheel {user}')
            self.incus_exec(
                fullname,
                ['sed', '-i',
                 '-e', '/%wheel[ \t]\\+ALL=(ALL)[ \t]\\+ALL/s/^/# /',
                 '-e', '/%wheel[ \t]\\+ALL=(ALL)[ \t]\\+NOPASSWD:/s/^# //',
                 '/etc/sudoers'])
            self.incus_exec(fullname, 'yum install -y openssh-server')
            self.incus_exec(fullname, 'systemctl restart sshd')
        elif info['series'] == 'debian':
            self.incus_exec(fullname, f'usermod -a -G sudo {user}')
            str_input = StringIO('%sudo   ALL=(ALL:ALL)  NOPASSWD: ALL')
            self.incus_exec(fullname, 'tee /etc/sudoers.d/group-sudo',
                            input=str_input)
            self.incus_exec(fullname, 'chmod 600 /etc/sudoers.d/group-sudo')
            self.incus_exec(fullname, 'apt-get update')
            self.incus_exec(fullname, 'apt-get install -y openssh-server')
            self.incus_exec(fullname, 'systemctl enable ssh')
            self.incus_exec(fullname, 'systemctl restart ssh')

    def netconf_rhel(self, fullname, ifname, param, info):
        ipv4_address = param.get('ipv4.address')
        if ipv4_address is None:
            self.logger.debug(f'{ifname}: no static ipv4.address')
            return  # disabled ... not configure
        ipv4_gateway = param.get('ipv4.gateway')
        dns_list = param.get('dns')
        if dns_list is not None:
            dns = ','.join(dns_list)
        else:
            dns = None
        real_ifname = self.convert_net_if(ifname, info)

        lines = self.incus_exec(fullname,
                                'nmcli --fields UUID,DEVICE connection show',
                                output=True)
        uuid = None
        for line in lines.splitlines():
            self.logger.debug(f'nmcli outpuit: {line}')
            fields = line.strip().split()
            if fields[1] == real_ifname:
                uuid = fields[0]
        if uuid is None:
            self.logger.warning('cannot set static IP address')
            return

        # DO NOT add new connection
        # self.incus_exec(fullname, 'nmcli connection add type ethernet con-name'
        #           + f' {ifname} ifname {real_ifname}')
        self.incus_exec(fullname, 'nmcli connection modify'
                   f' {uuid} ipv4.method manual ipv4.addr {ipv4_address}')
        if ipv4_gateway is not None:
            self.incus_exec(fullname, 'nmcli connection modify '
                            + f'{uuid} ipv4.gateway {ipv4_gateway}')
        if dns is not None:
            self.incus_exec(fullname, 'nmcli connection modify'
                            + f' {uuid} ipv4.dns "{dns}"')

    def netconf_debian(self, fullname, ifname, param, info, netplan_dict):
        ipv4_address = param.get('ipv4.address')
        ipv4_gateway = param.get('ipv4.gateway')
        dns_list = param.get('dns')
        real_ifname = self.convert_net_if(ifname, info)

        if ipv4_address is not None:
            new_yaml = f'''network:
  version: 2
  ethernets:
    {real_ifname}:
      addresses:
        - {ipv4_address}
      dhcp4: false
      dhcp6: false
      accept-ra: false
      link-local: []
'''
            new_dict = yaml.safe_load(new_yaml)
            d2 = new_dict['network']['ethernets'][real_ifname]
            if ipv4_gateway is not None:
                d2['routes'] = [{'to': 'default', 'via': ipv4_gateway}]
            if dns_list is not None:
                d2['nameservers'] = {'addresses': dns_list}
        else:
            new_yaml = f'''network:
  version: 2
  ethernets:
    {real_ifname}:
      dhcp4: true
      dhcp6: true
'''
            new_dict = yaml.safe_load(new_yaml)
        self.deep_update(netplan_dict, new_dict, override=True)

    def setup_network_static(self, info, fullname):
        # configure static IP address
        netstatic = info.get('network-static', None)
        if netstatic is None:
            return

        if info['series'] == 'rhel':
            self.incus_exec(fullname, 'yum install -y NetworkManager')
            self.incus_exec(fullname, 'systemctl enable NetworkManager')
            self.incus_exec(fullname, 'systemctl restart NetworkManager')
            for ifname, param in netstatic.items():
                self.netconf_rhel(fullname, ifname, param, info)
            self.incus_exec(fullname, 'systemctl restart NetworkManager')
        elif info['series'] == 'debian':
            netplan_dict = {
                # 'network': {
                #     'version': 2,
                #     'ethernets': {},
                # }
            }
            for ifname, param in netstatic.items():
                self.logger.debug(f'{fullname} {ifname} {str(param)}')
                self.netconf_debian(fullname, ifname, param,
                                    info, netplan_dict)
            netplan_path = '/etc/netplan/50-incus.yaml'
            self.incus_exec(fullname, f'touch {netplan_path}')
            self.incus_exec(fullname, f'chmod 600 {netplan_path}')
            str_input = StringIO(yaml.dump(netplan_dict, sort_keys=False))
            self.incus_exec(fullname, f'tee {netplan_path}', input=str_input)
            self.incus_exec(fullname, f'netplan apply')

    def launch_common(self):
        for name, fullname, info in self.name_iter():
            self.incus_launch(info, name, fullname)
        for name, fullname, info in self.name_iter():
            self.incus_wait_for_wakeup(fullname, info)
            if self.tobool(info['vm']) and info['series'] == 'rhel':
                # growpart for rhel VM
                self.growpart(fullname)
            if not self.control_buildimage:
                self.setup_user_and_ssh(info, fullname)
            self.setup_network_static(info, fullname)
            self.incus(f'stop {fullname}')
            self.mount_volume(fullname, info)
            self.incus(f'start {fullname}')
        for name, fullname, info in self.name_iter():
            self.incus_wait_for_wakeup(fullname, info)
        for name, fullname, info in self.name_iter():
            # run /host|buildimage/NAME/setup
            for cmd in info.get('setup', []):
                if cmd == '__RESTART__':
                    self.incus(f'restart {fullname}')
                    self.incus_wait_for_wakeup(fullname, info)
                else:
                    self.incus_exec(fullname, cmd)
        if self.control_buildimage:
            # publish buildimage
            for name, fullname, info in self.name_iter():
                remotes = info.get('publish-remote', None)
                aliases = info['publish-alias']
                self.incus(f'stop {fullname}')

                def publish(remote):
                    args = ['publish', fullname]
                    if remote is not None:
                        args.append(remote + ':')
                    for alias in aliases:
                        full_alias = self.project_prefix + alias
                        self.incus(['image', 'delete', full_alias],
                                   ignore_error=True)
                        args.extend(['--alias', full_alias])
                    self.incus(args)

                if remotes is None:
                    publish(None)
                else:
                    for remote in remotes:
                        publish(remote)

    def cmd_build(self):
        self.control_buildimage = True
        self.cmd_stop()
        self.cmd_delete()
        self.launch_common()

    def cmd_launch(self):
        self.control_buildimage = False
        self.launch_common()


if __name__ == '__main__':
    IncusAuto(program_name).main()
