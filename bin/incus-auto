#!/usr/bin/env python3

# Requirements:
# --- for Debian,Ubuntu series ---
# apt-get install python3 python3-docopt python3-schema python3-yaml
#
# --- for RHEL,CentOS series ---
# yum install     epel-release
# yum install     python3 python3-docopt python3-schema python3-pyyaml
#
# --- Or, install to ~/.local just for user's environment ---
# (required: python3-pip)
# pip3 install --user docopt schema PyYAML
#
# Coding style check:
# flake8 ./incus-auto

import os
import logging
import subprocess
import json
from pprint import pprint, pformat
from io import StringIO
import time
import copy
import inspect

from docopt import docopt
from schema import Schema, Or
import yaml

program_name = os.path.basename(__file__)

#TODO   {f} exec <name> <args>... [options]

__doc__ = """
Automating deployment system by Incus or LXD.

Usage:
  {f} init [options]
  {f} destroy [options]
  {f} ls [options]
  {f} ps [options]
  {f} config [options]
  {f} <command> <name>... [options]
  {f} <command> --all [options]

Options:
  -a, --all                 all buildimages or all hosts
  -b, --buildimage          control buildimages
  -f, --file=FILE           configuration file (YAML)
                            [default: incus-auto.yaml]
  -o, --override=FILE       override configuration file (if it exists)
                            [default: incus-auto.override.yaml]
  -l, --loglevel=LEVEL      log level (debug, info, warning, error)
                            [default: info]
  --encoding=CODEC          codec for filename encoding
          (https://docs.python.org/3/library/codecs.html#standard-encodings)
                            [default: utf-8]
  -?, -h, --help            show this help and exit

Command:
  init       initialize networks, profiles and buildimages
  destroy    destroy buildimages, profiles and networks
  build      (re)build images
  launch     launch hosts
  ps         list status of hosts
  ls         list hosts by `incus list` command
  config     check and show configuration parameters
  stop       stop hosts
  start      start hosts
  restart    restart hosts
  delete     delete stopped hosts, profile and network
""".format(f=program_name)

opt_schema = Schema({
    '--all': bool,
    '--buildimage': bool,
    '--file': str,
    '--override': str,
    '--loglevel': str,
    '--encoding': str,
    '--help': bool,
    '<command>': Or(str, None),
    'init': bool,
    'destroy': bool,
    'ls': bool,
    'ps': bool,
    'config': bool,
    '<name>': [str],
})

#TODO
conf_schema = Schema({
    
})

class CUI():
    def cui_init(self, program_name):
        self.program_name = program_name
        self._docopt = docopt(self.get_doc())
        # pprint(self._docopt)  # for debug
        self.opt = self.get_opt_schema().validate(self._docopt)
        self.loglevel_str = self.opt['--loglevel']

        loglevel_dict = {
            'debug': logging.DEBUG,
            'info': logging.INFO,
            'warning': logging.WARNING,
            'error': logging.ERROR,
        }
        self.loglevel = loglevel_dict[self.loglevel_str.lower()]
        # use stderr
        self.logger = self.logger_init()

    def logger_init(self):
        logger = logging.getLogger()  # RootLogger
        logger.setLevel(self.loglevel)
        stream = logging.StreamHandler()  # stderr
        if self.loglevel == logging.DEBUG:
            fmt = '%(filename)s:%(levelname)s:L%(lineno)d:' + \
                '%(asctime)s: %(message)s'
            fmt = fmt.format(self.program_name)
        elif self.loglevel == logging.INFO:
            fmt = '{}: %(message)s'.format(self.program_name)
        else:
            fmt = '%(message)s'
        formatter_stream = logging.Formatter(fmt=fmt, datefmt='%Y%m%d%H%M%S')
        stream.setFormatter(formatter_stream)
        stream.setLevel(self.loglevel)
        logger.addHandler(stream)
        return logger

    def get_doc(self):
        raise NotImplementedError

    def get_opt_chema(self):
        raise NotImplementedError

    def run(self):
        raise NotImplementedError

    def execv(self, args, input=None, output=None,
              timeout=None, textmode=False, ignore_error=False):
        if isinstance(args, str):
            args = args.split()
        out, err, ret = self.execv_raw(args, input, output, timeout, textmode)
        if textmode:
            err = err.rstrip()
        else:
            try:
                err = err.decode().rstrip()
            except Exception:
                self.logger.debug('cannot decode: err=%s', err)
        if ret != 0:
            msg = f'{str(args)}: {str(err)}'
            if ignore_error:
                self.logger.info('Error ignored: ' + msg)
                return
            else:
                raise Exception('Error: ' + msg)
        if err:
            self.logger.info(err)
        self.logger.debug(f'Success: {str(args)}')
        return out

    def execv_raw(self, args, input=None, output=None,
                  timeout=None, textmode=False):
        # input: read()able stream or None
        # output:
        #   True: use PIPE (return out, err)
        #   False: disable
        #   None: write to stdout and stderr directly
        if textmode:
            encoding = self.encoding
        else:
            encoding = None
        if input is not None:
            stdin = subprocess.PIPE
        else:
            stdin = subprocess.DEVNULL
        if output is None:
            stdout = None
        elif output:
            stdout = subprocess.PIPE
        else:
            stdout = subprocess.DEVNULL
        # self.logger.debug('Popen(args=%s)', str(args))
        proc = subprocess.Popen(
            args, shell=False, encoding=encoding, close_fds=True,
            stdin=stdin, stdout=stdout, stderr=stdout)
        try:
            if input is not None:
                out, err = proc.communicate(input.read(), timeout=timeout)
            else:
                out, err = proc.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            proc.kill()
            out, err = proc.communicate()
        ret = proc.wait()
        if out is None:
            out = ''
        if err is None:
            err = ''
        return out, err, ret

    @classmethod
    def dictpath(cls, d, dpath):
        if isinstance(dpath, list):
            keys = dpath
        else:
            keys = [key for key in dpath.split('/') if key]
        result = d
        for key in keys:
            try:
                result = result[key]
            except (KeyError, TypeError):
                return None
        return result

    @classmethod
    def tobool(cls, s):
        if isinstance(s, bool):
            return s
        t = ['true', 'yes', 'on', '1']
        return s.lower() in t

class IncusAuto(CUI):
    def __init__(self, program_name):
        self.cui_init(program_name)
        self.parse_opt()
        self.change_dir()
        self.load_conf()

    def get_doc(self):
        return __doc__

    def get_opt_schema(self):
        return opt_schema

    def parse_opt(self):
        self.names = self.opt['<name>']
        self.use_all = self.opt['--all']
        self.control_buildimage = self.opt['--buildimage']
        self.conf_file = self.opt['--file']
        self.override_file = self.opt['--override']
        self.encoding = self.opt['--encoding']

    def change_dir(self):
        self.basedir = os.path.dirname(os.path.realpath(self.conf_file))
        os.chdir(self.basedir)

    @classmethod
    def deep_update(cls, dst, src, override=False):
        def update_common(target, key, val):
            target_val = target.get(key, None)
            if isinstance(val, dict):
                if target_val is None:
                    target[key] = {}
                cls.deep_update(target[key], val, override)
            elif override or target_val is None:
                target[key] = val

        for k, v in src.items():
            if k == '__ANY__':
                for k2 in list(dst.keys()):
                    update_common(dst, k2, v)
            else:
                update_common(dst, k, v)

    def pformat(self, obj):
        if not hasattr(self, '_pformat_has_sort_dicts'):
            pformat_kwargs = inspect.getfullargspec(pformat).kwonlyargs
            self.logger.debug(f'pformat_kwargs={str(pformat_kwargs)}')
            # NOTE: Changed in Python 3.8: Added the sort_dicts parameter.
            if 'sort_dicts' in pformat_kwargs:
                self._pformat_has_sort_dicts = True
            else:
                self._pformat_has_sort_dicts = False
        if self._pformat_has_sort_dicts:
            return pformat(obj, sort_dicts=False)
        else:
            return pformat(obj)

    def load_conf(self):
        self.logger.debug(self.pformat(self.opt))
        with open(self.conf_file) as f:
            self.conf_dict = yaml.safe_load(f)
        if os.path.exists(self.override_file):
            with open(self.override_file) as f:
                override_dict = yaml.safe_load(f)
                self.deep_update(self.conf_dict, override_dict, override=True)
        self.logger.debug(self.pformat(self.conf_dict))

        # TODO set defaults
        config_defaults = {
            'config': {
                'incus_command': 'incus',
            },
            'buildimage': {
                '__ANY__': {
                    'vm': False,
                    'devices': {
                        'root': {
                            'size': '5GB',
                        },
                    },
                },
            },
            'host': {
                '__ANY__': {
                    'vm': False,
                    'devices': {
                        'root': {
                            'size': '5GB',
                        },
                    },
                },
            },
        }
        self.deep_update(self.conf_dict, config_defaults)
        self.logger.debug(self.pformat(self.conf_dict))

        for name in self.conf('/buildimage').keys():
            if self.is_defined(name, '/host'):
                raise Exception(
                    'Error: buildimage and host cannot be duplicated: '
                    + f'{dname}')
        self.project_prefix = self.conf('/config/project') + '-'
        self.stop_timeout = 60

    def conf(self, confpath):
        return self.dictpath(self.conf_dict, confpath)

    def host_iter(self, build=False):
        if build:
            for name in self.dictpath(self.conf_dict, '/buildimage').keys():
                yield (name, self.project_prefix + name)
        else:
            for name in self.dictpath(self.conf_dict, '/host').keys():
                yield (name, self.project_prefix + name)

    def is_defined(self, hostname, dpath):
        return hostname in self.conf(dpath).keys()

    def check_defined_host(self, hostname):
        if not self.is_defined(hostname, '/host'):
            raise Exception(f'Undefined host: {hostname}')

    def check_defined_buildimage(self, buildname):
        if not self.is_defined(buildname, '/buildimage'):
            raise Exception(f'Undefined buildimage: {buildname}')

    def incus(self, args, input=None, output=None, ignore_error=False):
        if isinstance(args, str):
            args = args.split()
        args = [self.conf('/config/incus_command')] + args
        return self.execv(args, textmode=True, input=input, output=output,
                          ignore_error=ignore_error)

    def incus_ls_json(self):
        j_str = self.incus('ls -f json', output=True)
        return json.loads(j_str)

    def incus_is_running(self, name):
        try:
            self.incus(['exec', name, 'hostname'])
            return True
        except Exception:
            return False

    def incus_wait_for_wakeup(self, name, net_if):
        while not self.incus_is_running(name):
            self.logger.info(f'Waiting for wake up: {name}')
            time.sleep(1)
        while self.incus_get_ipv4(name, net_if) is None:
            self.logger.info(f'Waiting until seeing IP address: {name}')
            time.sleep(1)

    def incus_get_ipv4(self, name, net_if):
        for hostinfo in self.incus_ls_json():
            if name != hostinfo['name']:
                continue
            addresses = self.dictpath(
                hostinfo, ['state', 'network', net_if, 'addresses'])
            if addresses is None:
                break
            for a in addresses:
                if a.get('family') == 'inet' \
                   and a.get('address', None) is not None:
                    return a['address']
            break
        return None

    def convert_disk_source(self, devices):
        for device, params in devices.items():
            if params.get('type') == 'disk':
                source = params.get('source', None)
                if source is not None \
                   and not source.startswith('/'):
                    found = os.path.realpath(
                        os.path.join(self.basedir, source))
                    self.logger.debug("source found=" + str(found))
                    devices[device]['source'] = found
        return devices

    def incus_each(self, cmd, args=[], build=False, ignore_error=False):
        if self.use_all:
            for name, fullname in self.host_iter(build):
                self.incus([cmd, fullname] + args,
                           ignore_error=ignore_error, output=True)
        else:  # specified hosts
            for hostname in self.names:
                if build:
                    self.check_defined_buildimage(hostname)
                else:
                    self.check_defined_host(hostname)
            for hostname in self.names:
                self.incus([cmd, self.project_prefix + hostname] + args,
                           ignore_error=ignore_error, output=True)

    def main(self):
        commands = {
            'init': self.cmd_init,
            'destroy': self.cmd_destroy,
            'ls': self.cmd_ls,
            'ps': self.cmd_ps,
            'config': self.cmd_config,
            'build': self.cmd_build,
            'launch': self.cmd_launch,
            'stop': self.cmd_stop,
            'delete': self.cmd_delete,
        }
        simple_commands = ['init', 'destroy', 'ls', 'ps', 'config']
        cmd_name = None
        for n in simple_commands:
            if self.opt[n]:
                cmd_name = n
                break
        if cmd_name is None:
            cmd_name = self.opt['<command>']
        # execute method
        commands[cmd_name]()

    def cmd_config(self):
        print(yaml.dump(self.conf_dict, sort_keys=False))

    def cmd_init(self):
        # create networks
        for netname in self.conf('/config/network').keys():
            self.incus(f'network create {netname}')
            d = self.conf(['config', 'network', netname])
            ystr = yaml.dump(d, sort_keys=False)
            self.logger.debug(ystr)
            str_input = StringIO(ystr)
            self.incus(f'network edit {netname}', input=str_input)
            self.logger.info(f'network: "{netname}" created')
            self.incus(f'network show {netname}')
        # create profiles
        for profname in self.conf('/config/profile').keys():
            fullname = self.project_prefix + profname
            self.incus(f'profile create {fullname}')
            d = self.conf(['config', 'profile', profname])
            devices = d.get('devices', None)
            if devices is not None:
                d['devices'] = self.convert_disk_source(devices)
            ystr = yaml.dump(d, sort_keys=False)
            self.logger.debug(ystr)
            str_input = StringIO(ystr)
            self.incus(f'profile edit {fullname}', input=str_input)
            self.logger.info(f'profile: "{fullname}" created')
            self.incus(f'profile show {fullname}')
        # create buildimages
        self.use_all = True
        self.cmd_build()

    def cmd_destroy(self):
        # delete buildimages
        self.use_all = True
        # self.incus_each('stop', ['-f'], build=True, ignore_error=True)
        self.incus_each('delete', ['-f'], build=True, ignore_error=True)
        # delete profiles
        for profname in self.conf('/config/profile').keys():
            fullname = self.project_prefix + profname
            self.incus(f'profile delete {fullname}', ignore_error=True,
                       output=True)
        # delete networks
        for netname in self.conf('/config/network').keys():
            self.incus(f'network delete {netname}', ignore_error=True,
                       output=True)

    def cmd_stop(self):
        self.incus_each('stop', ['--timeout', str(self.stop_timeout)],
                       build=self.control_buildimage, ignore_error=True)

    def cmd_delete(self):
        self.incus_each('delete',
                       build=self.control_buildimage, ignore_error=True)

    def cmd_ls(self):
        if self.use_all or len(self.names) == 0:
            print(self.incus(f'ls -c ns4t {self.project_prefix}'))
        else:
            for name in self.names:
                self.check_defined_host(name)
            for name in self.names:
                print(self.incus(f'ls -c ns4t {self.project_prefix}{name}$'))

    def cmd_ps(self):
        state_dict = {}
        fullname_max = 0
        state_max = 0
        if self.use_all or len(self.names) == 0:
            names = [n for n, full in
                     self.host_iter(build=self.control_buildimage)]
        else:
            names = self.names
            for name in names:
                if self.control_buildimage:
                    self.check_defined_buildimage(name)
                else:
                    self.check_defined_host(name)

        host_dict = {}
        for hostinfo in self.incus_ls_json():
            host_dict[hostinfo['name']] = hostinfo
        for name in names:
            fullname = self.project_prefix + name
            hostinfo = host_dict.get(fullname, None)
            if hostinfo is None:
                state = "NOTCREATED"
            else:
                state = hostinfo['config']['volatile.last_state.power']
            state_dict[fullname] = state
            fullname_len = len(fullname)
            if fullname_len > fullname_max:
                fullname_max = fullname_len
            state_len = len(state)
            if state_len > state_max:
                state_max = state_len
        for fullname, state in state_dict.items():
            print(f'{fullname:<{fullname_max}}  {state:<{fullname_max}}')

    def incus_launch1(self, info, name, fullname):
        image = info['image']
        args = ['launch', image, fullname]
        for p in info.get('profile', {}):
            args += ['-p', self.project_prefix + p]
        for devname, params in info.get('devices', {}).items():
            kvlist = []
            for key, val in params.items():
                kvlist.append(key + '=' + str(val))
            val = devname + ',' + ','.join(kvlist)
            args += ['-d', val]
        for key, val in info.get('config', {}).items():
            args += ['-c', key + '=' + str(val)]
        if self.tobool(info['vm']):
            args += ['--vm']
        else:  # container
            args += ['-c', 'security.nesting=true']
        self.incus(args)

    def growpart(self, fullname):
        self.incus(f'exec {fullname} -- '
                   + 'yum install -y e2fsprogs cloud-utils-growpart gdisk')
        mount = self.incus(f'exec {fullname} -- mount', output=True)
        device = None
        for line in mount.splitlines():
            fields = line.strip().split()
            if len(fields) >= 3 and fields[2] == "/":
                device = fields[0]
                break
        if device is not None:
            prefix = device.rstrip('0123456789')
            suffix = device[len(prefix):]
            self.incus(f'exec {fullname} -- growpart {prefix} {suffix}',
                       ignore_error=True)
            self.incus(f'exec {fullname} -- resize2fs {device}',
                       ignore_error=True)
            self.incus(f'exec {fullname} -- df -h')

    def launch_common(self, build=False):
        if build:
            target = 'buildimage'
        else:
            target = 'host'
        for name, fullname in self.host_iter(build):
            info = self.conf([target, name])
            self.incus_launch1(info, name, fullname)
        for name, fullname in self.host_iter(build):
            info = self.conf([target, name])
            if self.tobool(info['vm']):
                net_if = 'enp5s0'
            else:
                net_if = 'eth0'
            self.incus_wait_for_wakeup(fullname, net_if)
            if self.tobool(info['vm']) and info['series'] == 'rhel':
                # growpart for rhel VM
                self.growpart(fullname)

            # TODO configure eth1
        # TODO stop hosts
        # TODO configure static IP address for eth0 when dhcp == True
        # TODO configure raw.idmap : /config/idpmap
        #    echo -e "uid 1000 0" | lxc config set NAME raw.idmap -
        # TODO incus_mount : /host|buildimage/NAME/mount : SRC:DST
        # TODO start hosts
        # TODO setup sshd
        # TODO run /host|buildimage/NAME/setup
        if build:
            # TODO stop hosts
            pass # TODO publish buildimage

    def cmd_build(self):
        self.launch_common(build=True)

    def cmd_launch(self):
        #TODO self.launch_common(build=False)
        pass


if __name__ == '__main__':
    IncusAuto(program_name).main()
