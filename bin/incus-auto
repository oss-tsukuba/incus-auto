#!/usr/bin/env python3

# Requirements:
# --- for Debian,Ubuntu series ---
# apt-get install python3 python3-docopt python3-schema python3-yaml
#
# --- for RHEL,CentOS series ---
# yum install     epel-release
# yum install     python3 python3-docopt python3-schema python3-pyyaml
#
# --- Or, install to ~/.local just for user's environment ---
# (required: python3-pip)
# pip3 install --user docopt schema PyYAML
#
# Coding style check:
# flake8 ./incus-auto

import os
import logging
import subprocess
import json
from pprint import pprint, pformat
from io import StringIO
import time
import copy

from docopt import docopt
from schema import Schema, Or
import yaml

program_name = os.path.basename(__file__)

#TODO   {f} exec <name> <args>... [options]

__doc__ = """
Automating deployment system by Incus or LXD.

Usage:
  {f} init [options]
  {f} destroy [options]
  {f} ls [options]
  {f} ps [options]
  {f} <command> <name>... [options]
  {f} <command> --all [options]

Options:
  -a, --all                 all buildimages or all hosts
  -b, --buildimage          control buildimages
  -f, --file=FILE           configuration YAML file
                            [default: incus-auto.yaml]
  -l, --loglevel=LEVEL      log level (debug, info, warning, error)
                            [default: debug]
  --encoding=CODEC          codec for filename encoding
          (https://docs.python.org/3/library/codecs.html#standard-encodings)
                            [default: utf-8]
  -?, -h, --help            show this help and exit

Command:
  init       initialize networks, profiles and buildimages
  destroy    destroy buildimages, profiles and networks
  build      (re)build images
  launch     launch hosts
  ps         list status of hosts
  ls         list hosts by `incus list` command
  stop       stop hosts
  start      start hosts
  restart    restart hosts
  delete     delete stopped hosts, profile and network
""".format(f=program_name)

opt_schema = Schema({
    '--all': bool,
    '--buildimage': bool,
    '--file': str,
    '--loglevel': str,
    '--encoding': str,
    '--help': bool,
    '<command>': Or(str, None),
    'init': bool,
    'destroy': bool,
    'ls': bool,
    'ps': bool,
    '<name>': [str],
})

#TODO
conf_schema = Schema({
    
})

class CUI():
    def cui_init(self, program_name):
        self.program_name = program_name
        self._docopt = docopt(self.get_doc())
        # pprint(self._docopt)  # for debug
        self.opt = self.get_opt_schema().validate(self._docopt)
        self.loglevel_str = self.opt['--loglevel']

        loglevel_dict = {
            'debug': logging.DEBUG,
            'info': logging.INFO,
            'warning': logging.WARNING,
            'error': logging.ERROR,
        }
        self.loglevel = loglevel_dict[self.loglevel_str.lower()]
        # use stderr
        self.logger = self.logger_init()

    def logger_init(self):
        logger = logging.getLogger()  # RootLogger
        logger.setLevel(self.loglevel)
        stream = logging.StreamHandler()  # stderr
        if self.loglevel == logging.DEBUG:
            fmt = '%(filename)s:%(levelname)s:L%(lineno)d:' + \
                '%(asctime)s: %(message)s'
            fmt = fmt.format(self.program_name)
        elif self.loglevel == logging.INFO:
            fmt = '{}:%(levelname)s: %(message)s'.format(self.program_name)
        else:
            fmt = '%(message)s'
        formatter_stream = logging.Formatter(fmt=fmt, datefmt='%Y%m%d%H%M%S')
        stream.setFormatter(formatter_stream)
        stream.setLevel(self.loglevel)
        logger.addHandler(stream)
        return logger

    def get_doc(self):
        raise NotImplementedError

    def get_opt_chema(self):
        raise NotImplementedError

    def run(self):
        raise NotImplementedError

    def execv(self, args, stdin=None, stdout=False,
              timeout=None, textmode=False):
        out, err, ret = self.execv_raw(args, stdin, timeout, textmode)
        if textmode:
            err = err.rstrip()
        else:
            try:
                err = err.decode().rstrip()
            except Exception:
                self.logger.debug('cannot decode: err=%s', err)
        if ret != 0:
            msg = '{}: {}'.format(str(args), err)
            if err:
                self.logger.debug(msg)
                raise Exception(msg)
        if err:
            self.logger.info(err)
        return out

    def execv_raw(self, args, stdin=None,
                  timeout=None, textmode=False):
        self.logger.debug('Popen(args=%s)', str(args))
        if textmode:
            encoding = self.encoding
        else:
            encoding = None
        proc = subprocess.Popen(
            args, shell=False, encoding=encoding, close_fds=True,
            stdin=subprocess.PIPE, stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        try:
            if stdin is not None:
                out, err = proc.communicate(stdin.read(), timeout=timeout)
            else:
                out, err = proc.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            proc.kill()
            out, err = proc.communicate()
        ret = proc.wait()
        return out, err, ret

    @classmethod
    def dictpath(cls, d, dpath):
        if isinstance(dpath, list):
            keys = dpath
        else:
            keys = [key for key in dpath.split('/') if key]
        result = d
        for key in keys:
            try:
                result = result[key]
            except (KeyError, TypeError):
                return None
        return result

    @classmethod
    def tobool(cls, s):
        if isinstance(s, bool):
            return s
        t = ['true', 'yes', 'on', '1']
        return s.lower() in t

class IncusAuto(CUI):
    def __init__(self, program_name):
        self.cui_init(program_name)
        self.parse_opt()
        self.change_dir()
        self.load_conf()

    def get_doc(self):
        return __doc__

    def get_opt_schema(self):
        return opt_schema

    def parse_opt(self):
        self.names = self.opt['<name>']
        self.use_all = self.opt['--all']
        self.control_buildimage = self.opt['--buildimage']
        self.conf_file = self.opt['--file']
        # TODO self.override_file = self.opt['--override']
        self.encoding = self.opt['--encoding']

    def change_dir(self):
        self.basedir = os.path.dirname(os.path.realpath(self.conf_file))
        os.chdir(self.basedir)

    def set_default(self, base_dict, defaults):
        def common(base, key, val):
            base_val = base.get(key, None)
            if isinstance(val, dict):
                if base_val is None:
                    base[key] = {}
                self.set_default(base[key], val)
            elif base_val is None:
                base[key] = val

        for k, v in defaults.items():
            if k == '__ANY__':
                for k2 in list(base_dict.keys()):
                    common(base_dict, k2, v)
            else:
                common(base_dict, k, v)

    def load_conf(self):
        with open(self.conf_file) as f:
            self.conf_dict = yaml.safe_load(f)
        self.logger.debug(pformat(self.opt))
        self.logger.debug(pformat(self.conf_dict))

        # TODO
        config_defaults = {
            'config': {
                'incus_command': 'incus',
            },
            'buildimage': {
                '__ANY__': {
                    'disk': '5GB',
                }
            },
            'host': {
                '__ANY__': {
                    'disk': '5GB',
                }
            },
        }
        self.set_default(self.conf_dict, config_defaults)
        self.logger.debug(pformat(self.conf_dict))

        for name in self.conf('/buildimage').keys():
            if self.is_defined(name, '/host'):
                raise Exception(
                    'Error: buildimage and host cannot be duplicated: '
                    + f'{dname}')
        self.project_prefix = self.conf('/config/project') + '-'
        self.stop_timeout = 60

    def conf(self, confpath):
        return self.dictpath(self.conf_dict, confpath)

    def host_iter(self, build=False):
        if build:
            for name in self.dictpath(self.conf_dict, '/buildimage').keys():
                yield (name, self.project_prefix + name)
        else:
            for name in self.dictpath(self.conf_dict, '/host').keys():
                yield (name, self.project_prefix + name)

    def is_defined(self, hostname, dpath):
        return hostname in self.conf(dpath).keys()

    def check_defined_host(self, hostname):
        if not self.is_defined(hostname, '/host'):
            raise Exception(f'Undefined host: {hostname}')

    def check_defined_buildimage(self, buildname):
        if not self.is_defined(buildname, '/buildimage'):
            raise Exception(f'Undefined buildimage: {buildname}')

    def incus(self, args, stdin=None):
        if isinstance(args, str):
            args = args.split()
        args = [self.conf('/config/incus_command')] + args
        return self.execv(args, textmode=True, stdin=stdin)

    def incus_ls_json(self):
        j_str = self.incus('ls -f json')
        return json.loads(j_str)

    def incus_is_running(self, name):
        try:
            self.incus(['exec', name, 'hostname'])
            return True
        except Exception:
            return False

    def incus_wait_for_wakeup(self, name, net_if):
        while not self.incus_is_running(name):
            self.logger.info(f'Waiting for wake up: {name}')
            time.sleep(1)
        while self.incus_get_ipv4(name, net_if) is None:
            self.logger.info(f'Waiting until seeing IP address: {name}')
            time.sleep(1)

    def incus_get_ipv4(self, name, net_if):
        for hostinfo in self.incus_ls_json():
            if name != hostinfo['name']:
                continue
            addresses = self.dictpath(
                hostinfo, ['state', 'network', net_if, 'addresses'])
            if addresses is None:
                break
            for a in addresses:
                if a.get('family') == 'inet' \
                   and a.get('address', None) is not None:
                    return a['address']
            break
        return None

    def convert_disk_source(self, devices):
        for device, params in devices.items():
            if params.get('type') == 'disk':
                source = params.get('source', None)
                if source is not None \
                   and not source.startswith('/'):
                    found = os.path.realpath(
                        os.path.join(self.basedir, source))
                    self.logger.debug("source found=" + str(found))
                    devices[device]['source'] = found
        return devices

    def incus_cmd(self, cmd, args=[], build=False, ignore_error=False):
        if self.use_all:
            for name, fullname in self.host_iter(build):
                try:
                    self.incus([cmd, fullname] + args)
                    self.logger.info(f'Success: {cmd} "{name}"')
                except Exception as e:
                    if ignore_error:
                        self.logger.info(
                            f'Ignored: {cmd} "{name}": {str(e)}')
                    else:
                        raise
        else:  # specified hosts
            for hostname in self.names:
                if build:
                    self.check_defined_buildimage(hostname)
                else:
                    self.check_defined_host(hostname)
            for hostname in self.names:
                try:
                    self.incus([cmd, self.project_prefix + hostname] + args)
                    self.logger.info(f'Success: {cmd} "{hostname}"')
                except Exception as e:
                    if ignore_error:
                        self.logger.info(
                            f'Ignored: {cmd} "{hostname}": {str(e)}')
                    else:
                        raise

    def main(self):
        commands = {
            'init': self.init,
            'destroy': self.destroy,
            'ls': self.ls,
            'ps': self.ps,
            'build': self.build,
            'launch': self.launch,
            'stop': self.stop,
            'delete': self.delete,
        }
        # execute method
        if self.opt['init']:
            commands['init']()
        elif self.opt['destroy']:
            commands['destroy']()
        elif self.opt['ls']:
            commands['ls']()
        elif self.opt['ps']:
            commands['ps']()
        else:
            commands[self.opt['<command>']]()

    def init(self):
        # create networks
        for netname in self.conf('/config/network').keys():
            self.incus(f'network create {netname}')
            d = self.conf(['config', 'network', netname])
            ystr = yaml.dump(d)
            self.logger.debug(ystr)
            strio = StringIO(ystr)
            self.incus(f'network edit {netname}', stdin=strio)
            self.logger.info(f'network: "{netname}" created')
        # create profiles
        for profname in self.conf('/config/profile').keys():
            fullname = self.project_prefix + profname
            self.incus(f'profile create {fullname}')
            d = self.conf(['config', 'profile', profname])
            devices = d.get('devices', None)
            if devices is not None:
                d['devices'] = self.convert_disk_source(devices)
            ystr = yaml.dump(d)
            self.logger.debug(ystr)
            strio = StringIO(ystr)
            self.incus(f'profile edit {fullname}', stdin=strio)
            self.logger.info(f'profile: "{fullname}" created')
        # create buildimages
        self.use_all = True
        self.build()

    def destroy(self):
        # delete buildimages
        self.use_all = True
        self.incus_cmd('stop', ['-f'], build=True, ignore_error=True)
        self.incus_cmd('delete', ['-f'], build=True, ignore_error=True)
        # delete profiles
        for profname in self.conf('/config/profile').keys():
            fullname = self.project_prefix + profname
            try:
                self.incus(f'profile delete {fullname}')
                self.logger.info(f'profile: "{fullname}" deleted')
            except Exception as e:
                self.logger.info(
                    f'Ignored: profile delete "{fullname}": {str(e)}')
        # delete networks
        for netname in self.conf('/config/network').keys():
            try:
                self.incus(f'network delete {netname}')
                self.logger.info(f'network: "{netname}" deleted')
            except Exception as e:
                self.logger.info(
                    f'Ignored: network delete "{netname}": {str(e)}')

    def stop(self):
        self.incus_cmd('stop', ['--timeout', str(self.stop_timeout)],
                       build=self.control_buildimage, ignore_error=True)

    def delete(self):
        self.incus_cmd('delete',
                       build=self.control_buildimage, ignore_error=True)

    def ls(self):
        if self.use_all or len(self.names) == 0:
            print(self.incus(f'ls -c ns4t {self.project_prefix}'))
        else:
            for name in self.names:
                self.check_defined_host(name)
            for name in self.names:
                print(self.incus(f'ls -c ns4t {self.project_prefix}{name}$'))

    def ps(self):
        state_dict = {}
        host_max = 0
        state_max = 0
        if self.use_all or len(self.names) == 0:
            names = [n for n, full in
                     self.host_iter(build=self.control_buildimage)]
        else:
            names = self.names
            for name in names:
                if self.control_buildimage:
                    self.check_defined_buildimage(name)
                else:
                    self.check_defined_host(name)

        host_dict = {}
        for hostinfo in self.incus_ls_json():
            host_dict[hostinfo['name']] = hostinfo
        for name in names:
            host = self.project_prefix + name
            hostinfo = host_dict.get(host, None)
            if hostinfo is None:
                state = "NOTCREATED"
            else:
                state = hostinfo['config']['volatile.last_state.power']
            state_dict[host] = state
            host_len = len(host)
            if host_len > host_max:
                host_max = host_len
            state_len = len(state)
            if state_len > state_max:
                state_max = state_len
        for host, state in state_dict.items():
            print(f'{host:<{host_max}}  {state:<{state_max}}')

    def incus_launch1(self, info, name, fullname):
        image = info['image']
        args = ['launch', image, fullname]
        for p in info.get('profile', {}):
            args += ['-p', self.project_prefix + p]
        for devname, params in info.get('devices', {}).items():
            kvlist = []
            for key, val in params.items():
                kvlist.append(key + '=' + str(val))
            val = devname + ',' + ','.join(kvlist)
            args += ['-d', val]
        for key, val in info.get('config', {}).items():
            args += ['-c', key + '=' + str(val)]
        if self.tobool(info.get('vm', False)):  # default: container
            args += ['--vm']
        else:  # container
            args += ['-c', 'security.nesting=true']
        self.incus(args)

    def launch_common(self, build=False):
        if build:
            target = 'buildimage'
        else:
            target = 'host'
        for name, fullname in self.host_iter(build):
            info = self.conf([target, name])
            self.incus_launch1(info, name, fullname)
        for name, fullname in self.host_iter(build):
            info = self.conf([target, name])
            if self.tobool(info.get('vm', False)):
                net_if = 'enp5s0'
            else:
                net_if = 'eth0'
            self.incus_wait_for_wakeup(fullname, net_if)
            # TODO growpart for rhel VM
            # TODO configure eth1
        # TODO stop hosts
        # TODO configure static IP address for eth0 when dhcp == True
        # TODO configure raw.idmap : /config/idpmap
        #    echo -e "uid 1000 0" | lxc config set NAME raw.idmap -
        # TODO incus_mount : /host|buildimage/NAME/mount : SRC:DST
        # TODO start hosts
        # TODO setup sshd
        # TODO run /host|buildimage/NAME/setup
        if build:
            # TODO stop hosts
            pass # TODO publish buildimage

    def build(self):
        self.launch_common(build=True)

    def launch(self):
        self.launch_common(build=False)

if __name__ == '__main__':
    IncusAuto(program_name).main()
