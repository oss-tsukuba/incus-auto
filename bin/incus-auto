#!/usr/bin/env python3

# Requirements:
# --- for Debian,Ubuntu series ---
# apt-get install python3 python3-docopt python3-schema python3-yaml
#
# --- for RHEL,CentOS series ---
# yum install     epel-release
# yum install     python3 python3-docopt python3-schema python3-pyyaml
#
# --- Or, install to ~/.local just for user's environment ---
# (required: python3-pip)
# pip3 install --user docopt schema PyYAML
#
# Coding style check:
# flake8 ./incus-auto

import os
import logging
import subprocess
import json
from pprint import pformat
from io import StringIO
import time
import inspect
import shlex

from docopt import docopt
from schema import Schema, Or
import yaml

program_name = os.path.basename(__file__)

default_conf1 = 'incus-auto.yaml'
default_conf2 = 'incus-auto.override.yaml'

__doc__ = """
Automating deployment system by Incus or LXD.

Usage:
  {f} init [options]
  {f} destroy [options]
  {f} ls [options]
  {f} ps [options]
  {f} shell <name> [--root] [options]
  {f} exec <name> [--root] [options] [--] <args>...
  {f} exec --all [--root] [options] [--] <args>...
  {f} config [options]
  {f} ansible-inventory [options]
  {f} inv [options]
  {f} etchosts [options]
  {f} <command> <name> [options]
  {f} <command> --all [options]

Options:
  -a, --all                 control all hosts (or buildimages)
  -b, --buildimage          control buildimages
  -c, --config=FILEs        configuration files (YAML) (comma separator)
                            [default: {d1},{d2}]
  -f, --force               force to stop
  --root                    execute by root
  -l, --loglevel=LEVEL      log level (debug, info, warning, error)
                            [default: info]
  --encoding=CODEC          codec for filename encoding
          (https://docs.python.org/3/library/codecs.html#standard-encodings)
                            [default: utf-8]
  -?, -h, --help            show this help and exit

Command:
  init               initialize networks, profiles and buildimages
  destroy            destroy buildimages, profiles and networks
  build              (re)build images
  launch             launch hosts
  ps                 list status of hosts
  ls                 list hosts by `incus list` command
  shell              open shell
  exec               execute command
  wait               wait for startup of hosts
  config             check and show configuration parameters
  ansible-inventory  for ansible-inventory -i -
  inv                alias of ansible-inventory
  etchosts           print list for /etc/hosts
  update-etchosts    update /etc/hosts for hosts
  stop               stop hosts
  start              start hosts
  restart            restart hosts
  delete             delete stopped hosts, profile and network

Multiple targets:
  Example:
    {f} exec host1,host2 hostname
""".format(f=program_name, d1=default_conf1, d2=default_conf2)

opt_schema = Schema({
    '--all': bool,
    '--buildimage': bool,
    '--config': str,
    '--force': bool,
    '--root': bool,
    '--loglevel': str,
    '--encoding': str,
    '--help': bool,
    '<command>': Or(str, None),
    'init': bool,
    'destroy': bool,
    'ls': bool,
    'ps': bool,
    'shell': bool,
    'exec': bool,
    'config': bool,
    'ansible-inventory': bool,
    'inv': bool,
    'etchosts': bool,
    '<name>': Or(str, None),
    '<args>': [str],
    '--': bool,
})


class CUI():
    def cui_init(self, program_name):
        self.program_name = program_name
        self._docopt = docopt(self.get_doc())
        self.opt = self.get_opt_schema().validate(self._docopt)
        self.loglevel_str = self.opt['--loglevel']

        loglevel_dict = {
            'debug': logging.DEBUG,
            'info': logging.INFO,
            'warning': logging.WARNING,
            'error': logging.ERROR,
        }
        self.loglevel = loglevel_dict[self.loglevel_str.lower()]
        # use stderr
        self.logger = self.logger_init()

    def logger_init(self):
        logger = logging.getLogger()  # RootLogger
        logger.setLevel(self.loglevel)
        stream = logging.StreamHandler()  # stderr
        if self.loglevel == logging.DEBUG:
            fmt = '%(filename)s:%(levelname)s:L%(lineno)d:' + \
                '%(asctime)s: %(message)s'
            fmt = fmt.format(self.program_name)
        elif self.loglevel == logging.INFO:
            fmt = '{}: %(message)s'.format(self.program_name)
        else:
            fmt = '%(message)s'
        formatter_stream = logging.Formatter(fmt=fmt, datefmt='%Y%m%d%H%M%S')
        stream.setFormatter(formatter_stream)
        stream.setLevel(self.loglevel)
        logger.addHandler(stream)
        return logger

    def get_doc(self):
        raise NotImplementedError

    def get_opt_chema(self):
        raise NotImplementedError

    def run(self):
        raise NotImplementedError

    def execv(self, args, input=None, output=None,
              timeout=None, textmode=False, ignore_error=False):
        if isinstance(args, str):
            # ex. shlex.split('a b "c d" \\"e')
            #     -> ['a', 'b', 'c d', '"e']
            args = shlex.split(args)
        out, err, ret = self.execv_raw(args, input=input, output=output,
                                       timeout=timeout, textmode=textmode)
        if textmode:
            err = err.rstrip()
        else:
            try:
                err = err.decode().rstrip()
            except Exception:
                self.logger.debug('cannot decode: err=%s', err)
        if ret != 0:
            msg = f'{str(args)}: {str(err)}'
            if ignore_error:
                self.logger.debug(f'Ignored (exit status={ret}): {msg}')
                return
            else:
                raise Exception(f'Error (exit status={ret}): {msg}')
        if err:
            self.logger.info(err)
        self.logger.debug(f'Success: {str(args)}')
        return out

    def execv_raw(self, args, input=None, output=None,
                  timeout=None, textmode=False):
        # input:
        #   read()able stream object
        #   False: disable(/dev/null)
        #   None: read from stdin
        # output:
        #   True: use PIPE (return out, err)
        #   False: disable(/dev/null)
        #   None: write to stdout and stderr directly
        if textmode:
            encoding = self.encoding
        else:
            encoding = None
        if input is None:
            stdin = None
        elif input is False:
            stdin = subprocess.DEVNULL
        else:  # stream
            stdin = subprocess.PIPE
        if output is None:
            stdout = None
        elif output:
            stdout = subprocess.PIPE
        else:
            stdout = subprocess.DEVNULL
        # self.logger.debug('Popen(args=%s)', str(args))
        proc = subprocess.Popen(
            args, shell=False, encoding=encoding, close_fds=True,
            stdin=stdin, stdout=stdout, stderr=stdout)
        try:
            if input is not None:
                out, err = proc.communicate(input.read(), timeout=timeout)
            else:
                out, err = proc.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            proc.kill()
            out, err = proc.communicate()
        ret = proc.wait()
        if out is None:
            out = ''
        if err is None:
            err = ''
        return out, err, ret

    @classmethod
    def dictpath(cls, d, dpath):
        if isinstance(dpath, list):
            keys = dpath
        else:
            keys = [key for key in dpath.split('/') if key]
        result = d
        for key in keys:
            try:
                result = result[key]
            except (KeyError, TypeError):
                return None
        return result

    @classmethod
    def tobool(cls, s):
        if isinstance(s, bool):
            return s
        return s.lower() in ['true', 'yes', 'on', 'enable']


class IncusAuto(CUI):
    def __init__(self, program_name):
        self.cui_init(program_name)
        self.parse_opt()
        self.change_dir()
        self.load_conf()
        self.check_required()

    def get_doc(self):
        return __doc__

    def get_opt_schema(self):
        return opt_schema

    def parse_opt(self):
        name = self.opt['<name>']
        if name is not None:
            self.names = name.split(',')
        else:
            self.names = []
        self.use_all = self.opt['--all']  # CANNOT be changed outside of cmd_*
        self.control_buildimage = self.opt['--buildimage']
        self.conf_files = self.opt['--config'].split(',')
        self.force = self.opt['--force']
        self.encoding = self.opt['--encoding']
        self.user_is_root = self.opt['--root']

    def change_dir(self):
        self.basedir = os.path.realpath(os.path.dirname(self.conf_files[0]))
        os.chdir(self.basedir)

    @classmethod
    def deep_update(cls, dst, src, override=False):
        def update_common(target, key, val):
            target_val = target.get(key, None)
            if isinstance(val, dict):
                if target_val is None:
                    target[key] = {}
                cls.deep_update(target[key], val, override)
            elif override or target_val is None:
                target[key] = val

        for k, v in src.items():
            if k == '__ANY__':
                for k2 in list(dst.keys()):
                    update_common(dst, k2, v)
            else:
                update_common(dst, k, v)

    def pformat(self, obj):
        if not hasattr(self, '_pformat_has_sort_dicts'):
            pformat_kwargs = inspect.getfullargspec(pformat).kwonlyargs
            self.logger.debug(f'pformat_kwargs={str(pformat_kwargs)}')
            # NOTE: Changed in Python 3.8: Added the sort_dicts parameter.
            if 'sort_dicts' in pformat_kwargs:
                self._pformat_has_sort_dicts = True
            else:
                self._pformat_has_sort_dicts = False
        if self._pformat_has_sort_dicts:
            return pformat(obj, sort_dicts=False)
        else:
            return pformat(obj)

    def load_conf(self):
        self.logger.debug(self.pformat(self.opt))
        self.conf_dict = {}
        for conf_file in self.conf_files:
            if os.path.exists(conf_file):
                with open(conf_file) as f:
                    override_dict = yaml.safe_load(f)
                    self.deep_update(self.conf_dict,
                                     override_dict, override=True)
                self.logger.debug(conf_file + ': load and override: '
                                  + self.pformat(self.conf_dict))
            elif conf_file != default_conf1 and conf_file != default_conf2:
                if '.override.' in conf_file:
                    self.logger.debug(f'IGNORE: File not found: {conf_file}')
                else:
                    raise FileNotFoundError(conf_file)

        # define defaults
        config_defaults = {
            'config': {
                'incus_command': 'incus',
                'default_pool': 'default',
                'idmap': False,
                'user': 'admin',  # main guest user
                'uid': 2000,
                'use_sshd': True,
                # '' means "disabled"
                'ssh_authorized_keys': 'ssh_authorized_keys',
                'etchosts': True,
                'network': {},
                'stop_timeout': 300,
                'start_timeout': 300,
            },
            'buildimage': {
                '__ANY__': {
                    'vm': False,
                    'devices': {  # not null
                        # 'root': {
                        #     'size': '5GB',
                        # },
                    },
                },
            },
            'host': {
                '__ANY__': {
                    'vm': False,
                    'sshd': True,
                    'devices': {  # not null
                        # 'root': {
                        #     'size': '5GB',
                        # },
                    },
                },
            },
        }
        self.deep_update(self.conf_dict, config_defaults, override=False)
        self.logger.debug('self.conf_dict (set defaults): '
                          + self.pformat(self.conf_dict))

        for name in self.conf('/buildimage').keys():
            if self.is_defined(name, '/host'):
                raise Exception(
                    'Error: buildimage and host cannot be duplicated: ' + name)
        self.project_prefix = self.conf('/config/project') + '-'
        self.incus_command = self.conf('/config/incus_command')
        #self.stop_timeout = 300  # TODO opt
        #self.start_timeout = 300  # TODO opt
        self.stop_timeout = self.conf('/config/stop_timeout')
        self.start_timeout = self.conf('/config/start_timeout')

    def check_required(self):
        conf_use_sshd = self.conf('/config/use_sshd', False)
        if conf_use_sshd:
            self.authorized_keys = self.convert_fullpath(
                self.conf('/config/ssh_authorized_keys'))
        else:
            self.authorized_keys = None
        if self.authorized_keys is not None:
            if not os.access(self.authorized_keys, os.R_OK):
                raise Exception(f'Error: cannot read: {self.authorized_keys}')

    # DO NOT OVERWRITE
    def conf(self, confpath, default=None, notfound=False):
        result = self.dictpath(self.conf_dict, confpath)
        if result is None:
            if notfound:
                raise Exception(f'incus-auto.yaml: {confpath}: not defined')
            return default
        return result

    def depend_name_sort(self, d):
        limit = len(d.keys())

        def depth(name, n):
            max_dep = n
            if max_dep >= limit:
                self.logger.debug(f'depth({name}, {n}): {max_dep} LIMIT')
                return max_dep
            info = d.get(name, None)
            if info is None:
                return max_dep
            depend_list = info.get('depend', None)
            if depend_list is None:
                return max_dep
            if isinstance(depend_list, str):
                depend_list = depend_list.split(',')
            for item in depend_list:
                tmp = depth(item, n+1)
                if tmp > max_dep:
                    max_dep = tmp
            self.logger.debug(f'depth({name}, {n}): {max_dep}')
            return max_dep

        def custom_key(name):
            # self.logger.debug(f'depend_name_sort: {name}: start')
            dep = depth(name, 0)
            # self.logger.debug(f'depend_name_sort: {name}: result={dep}')
            return dep

        return sorted(d.keys(), key=custom_key)

    def name_iter(self, use_all):
        if self.control_buildimage:
            target_path = '/buildimage'
        else:
            target_path = '/host'
        d = self.conf(target_path)
        if use_all:
            for name in self.depend_name_sort(d):
                yield (name, self.project_prefix + name, d[name])
        else:  # specified hosts
            target_dict = {}
            for name in self.names:
                target_dict[name] = d[name]
            for name in self.depend_name_sort(target_dict):
                self.check_defined(name, target_path)
                yield (name, self.project_prefix + name, d[name])

    def is_defined(self, name, dpath):
        return name in self.conf(dpath).keys()

    def check_defined(self, name, dpath):
        if not self.is_defined(name, dpath):
            raise Exception(f'Undefined {dpath}: {name}')

    def incus(self, args, input=None, output=None, ignore_error=False):
        if isinstance(args, str):
            args = shlex.split(args)
        if isinstance(input, str):
            input = StringIO(input)
        args = [self.incus_command] + args
        return self.execv(args, textmode=True, input=input, output=output,
                          ignore_error=ignore_error)

    def fullname_to_shortname(self, fullname):
        return fullname[len(self.project_prefix):]

    def get_env(self, fullname):
        name = self.fullname_to_shortname(fullname)
        envvar1 = self.conf('/config/envvar')
        if self.control_buildimage:
            envvar2 = self.conf(f'/buildimage/{name}/envvar')
        else:
            envvar2 = self.conf(f'/host/{name}/envvar')
        if envvar1 is not None:  # dict
            e_copy = envvar1.copy()
            if envvar2 is not None:
                self.deep_update(e_copy, envvar2, override=True)
                return e_copy
            else:
                return e_copy
        else:
            return envvar2

    def incus_exec(self, fullname, args, user_is_root=True,
                   input=None, output=None, ignore_error=False, retry=1):
        for i in range(retry):
            try:
                return self._incus_exec(fullname, args,
                                        user_is_root=user_is_root,
                                        input=input, output=output,
                                        ignore_error=ignore_error)
            except Exception:
                if i >= retry - 1:
                    raise
                self.logger.debug('RETRY: incus exec')
                time.sleep(1)

    def _incus_exec(self, fullname, args, user_is_root=True,
                    input=None, output=None, ignore_error=False, retry=1):
        fullargs = ['exec', fullname]
        env = self.get_env(fullname)
        self.logger.debug('envvar: \n' + pformat(env))
        envkeys = []
        if env is not None:
            for k, v in env.items():
                env_str = f'{k}={v}'
                fullargs += ['--env', env_str]
                envkeys += [k]
        fullargs += ['--']
        if not user_is_root:
            envkeys_str = ','.join(envkeys)
            fullargs += ['sudo', '-i', f'--preserve-env={envkeys_str}',
                         '-u', self.conf('/config/user')]
        if isinstance(args, str):
            args = shlex.split(args)
        fullargs += args
        return self.incus(fullargs, input=input, output=output,
                          ignore_error=ignore_error)

    def incus_start(self, fullname):
        self.incus(['start', fullname])

    def incus_stop(self, fullname, force=False, timeout=-1, ignore_error=False):
        args = ['stop', fullname, '--verbose']
        if timeout == -1:
            timeout = self.stop_timeout
        if timeout is not None and timeout > 0:
            args += ['--timeout', str(timeout)]
        if self.force or force:
            args.append('--force')
        self.incus(args, ignore_error=ignore_error)

    def incus_ls_info(self):
        j_str = self.incus('ls -f json', output=True)
        return json.loads(j_str)

    def incus_is_running(self, name):
        try:
            self.incus(['exec', name, 'hostname'], output=False)
            return True
        except Exception:
            return False

    def convert_net_if(self, net_if, info):
        if not self.tobool(info['vm']):
            return net_if
        table = {
            'eth0': 'enp5s0',
            'eth1': 'enp6s0',
        }
        return table[net_if]

    def incus_wait_for_wakeup(self, fullname, info):
        net_if = self.convert_net_if('eth0', info)
        first = True
        count = 0
        while not self.incus_is_running(fullname):
            count += 1
            if count == 1 or self.loglevel == logging.DEBUG:
                self.logger.info(f'Waiting for startup: {fullname}')
            else:
                print('.', end='', flush=True)
            if count % self.start_timeout == 0:
                self.logger.warning(
                    f'{fullname} is no responding, restarting...')
                self.incus_stop(fullname, force=True)
                self.incus_start(fullname)
            time.sleep(1)
        if count != 1:
            print('')
        first = True
        while self.incus_get_ipv4(fullname, net_if) is None:
            if first or self.loglevel == logging.DEBUG:
                self.logger.info('Waiting until seeing IP address:'
                                 + f' {fullname}')
                first = False
            else:
                print('.', end='', flush=True)
            time.sleep(1)
        if not first:
            print('')

    def incus_get_ipv4(self, fullname, net_if, ls_info=None):
        if ls_info is None:
            ls_info = self.incus_ls_info()
        for hostinfo in ls_info:
            if fullname != hostinfo['name']:
                continue
            addresses = self.dictpath(
                hostinfo, ['state', 'network', net_if, 'addresses'])
            if addresses is None:
                break
            for a in addresses:
                if a.get('family') == 'inet' \
                   and a.get('address', None) is not None:
                    return a['address']
            break
        return None

    def convert_fullpath(self, path):
        if path is None:
            return None
        if path == '':
            return None
        path = os.path.expandvars(path)
        path = os.path.expanduser(path)
        if not path.startswith('/'):
            path = os.path.join(self.basedir, path)
        return os.path.realpath(path)

    def convert_default_pool(self, pool):
        if pool == '__DEFAULT__':
            return self.conf('/config/default_pool')
        else:
            return pool

    def convert_disk_source(self, devices):
        # SEE ALSO: mount_volume()
        for device, params in devices.items():
            if params.get('type') == 'disk':
                source = params.get('source', None)
                fullpath = None
                # to ignore "agent:config, etc."
                if source is not None and os.path.exists(source):
                    fullpath = self.convert_fullpath(source)
                if fullpath is not None:
                    self.logger.debug("source: fullpath=" + str(fullpath))
                    devices[device]['source'] = fullpath
                pool = params.get('pool')
                if pool is not None:
                    # SEE ALSO: create_block_device()
                    devices[device]['pool'] = self.convert_default_pool(pool)
        return devices

    def incus_each(self, cmd, args=[], build=False, ignore_error=False):
        if build:
            self.control_buildimage = build
        for name, fullname, info in self.name_iter(self.use_all):
            print(f'{self.incus_command} {cmd} {fullname}')
            self.incus([cmd, fullname] + args,
                       ignore_error=ignore_error,
                       output=True)  # err in Exception

    def main(self):
        commands = {
            'init': self.cmd_init,
            'destroy': self.cmd_destroy,
            'ls': self.cmd_ls,
            'ps': self.cmd_ps,
            'shell': self.cmd_shell,
            'exec': self.cmd_exec,
            'wait': self.cmd_wait,
            'config': self.cmd_config,
            'ansible-inventory': self.cmd_ansible_inventory,
            'inv': self.cmd_ansible_inventory,
            'etchosts': self.cmd_etchosts,
            'update-etchosts': self.cmd_update_etchosts,
            'build': self.cmd_build,
            'launch': self.cmd_launch,
            'start': self.cmd_start,
            'restart': self.cmd_restart,
            'stop': self.cmd_stop,
            'delete': self.cmd_delete,
        }
        simple_commands = ['init',
                           'destroy',
                           'ls',
                           'ps',
                           'shell',
                           'exec',
                           'config',
                           'ansible-inventory',
                           'inv',
                           'etchosts',
                           ]
        cmd_name = None
        for n in simple_commands:
            if self.opt[n]:
                cmd_name = n
                break
        if cmd_name is None:
            cmd_name = self.opt['<command>']
        # execute method
        commands[cmd_name]()

    def cmd_config(self):
        print(yaml.dump(self.conf_dict, sort_keys=False))

    def conf_ipv4(self, name):
        ip = self.conf(f'/host/{name}/network-static/eth0/ipv4.address')
        if ip is None:
            ip = self.conf(f'/host/{name}/devices/eth0/ipv4.address')
        if ip is None:
            return None
        return ip.split('/')[0]

    def cmd_ansible_inventory(self):
        user = self.conf('/config/user')
        inv = {
            'all': {
                'vars': {
                    'ansible_user': user,
                },
            },
        }
        envvar1 = self.conf('/config/envvar')
        if envvar1 is not None:
            inv['all']['vars'].update(envvar1)

        for name, fullname, info in self.name_iter(True):
            groups = info.get('group')
            envvar2 = info.get('envvar')

            if groups is None:
                continue
            if isinstance(groups, str):
                groups = groups.split(',')
            for group in groups:
                glist = group.split('/')
                parent = glist[:-1]
                lastgrp = glist[-1]
                d = inv
                for g in parent:
                    gval = d.get(g, {})
                    d[g] = gval
                    children = gval.get('children', {})
                    gval['children'] = children
                    d = children
                gval = d.get(lastgrp, {})
                d[lastgrp] = gval
                hosts = gval.get('hosts', {})
                gval['hosts'] = hosts
                if envvar2 is None:
                    hosts[name] = None
                else:
                    hosts[name] = envvar2

        def hide_null(self, _):
            return self.represent_scalar('tag:yaml.org,2002:null', '')

        yaml.add_representer(type(None), hide_null)
        print(yaml.dump(inv, sort_keys=False))

    def gen_etchosts(self):
        hosts = []
        ls_info = self.incus_ls_info()
        for name, fullname, info in self.name_iter(True):
            net_if = self.convert_net_if('eth0', info)
            ip = self.incus_get_ipv4(fullname, net_if, ls_info)
            if ip is None:
                ip = self.conf_ipv4(name)
            if ip is None:
                continue  # skip
            # aliases
            alt = self.conf(f'/host/{name}/alternative')
            alt_str = ''
            if alt is not None:
                alt_str = ' ' + ' '.join(alt)
            hosts.append(f'{ip}    {name} {fullname}{alt_str}')
        return hosts

    def cmd_etchosts(self):
        self.use_all = True
        for host in self.gen_etchosts():
            print(host)

    def cmd_init(self):
        # create networks
        for netname in self.conf('/config/network').keys():
            self.incus(f'network create {netname}')
            d = self.conf(['config', 'network', netname])
            ystr = yaml.dump(d, sort_keys=False)
            self.logger.debug(ystr)
            str_input = StringIO(ystr)
            self.incus(f'network edit {netname}', input=str_input)
            self.logger.info(f'network: "{netname}" created')
            self.incus(f'network show {netname}')
        # create profiles
        for profname in self.conf('/config/profile').keys():
            fullname = self.project_prefix + profname
            self.incus(f'profile create {fullname}')
            d = self.conf(['config', 'profile', profname])
            devices = d.get('devices', None)
            if devices is not None:
                d['devices'] = self.convert_disk_source(devices)
            ystr = yaml.dump(d, sort_keys=False)
            self.logger.debug(ystr)
            str_input = StringIO(ystr)
            self.incus(f'profile edit {fullname}', input=str_input)
            self.incus(f'profile show {fullname}')
            self.logger.info(f'profile: "{fullname}" created')

    def cmd_destroy(self):
        # delete buildimages
        self.use_all = True
        self.incus_each('delete', ['-f'], build=True, ignore_error=True)
        # delete profiles
        for profname in self.conf('/config/profile').keys():
            fullname = self.project_prefix + profname
            try:
                self.incus(f'profile show {fullname}', output=False)
                exist = True
            except Exception:
                exist = False
            if exist:
                self.incus(f'profile delete {fullname}', ignore_error=False,
                           output=True)
                print(f'{self.incus_command} profile delete {fullname}')
        # delete networks
        for netname in self.conf('/config/network').keys():
            try:
                self.incus(f'network show {netname}', output=False)
                exist = True
            except Exception:
                exist = False
            if exist:
                self.incus(f'network delete {netname}', ignore_error=False,
                           output=True)
                print(f'{self.incus_command} network delete {netname}')

    def cmd_start(self):
        self.incus_each('start', ['--verbose'],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_restart(self):
        self.incus_each('restart', ['--verbose',
                                    '--timeout', str(self.stop_timeout)],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_stop(self):
        opt = ['--verbose', '--timeout', str(self.stop_timeout)]
        if self.force:
            opt.append('--force')
        self.incus_each('stop', opt,
                        build=self.control_buildimage, ignore_error=True)

    def cmd_delete(self):
        self.incus_each('delete', ['--verbose'],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_update_etchosts(self):
        for name, fullname, info in self.name_iter(self.use_all):
            print(f'update /etc/hosts: {name}')
            self.update_etchosts(info, fullname)

    def cmd_ls(self):
        if self.use_all or len(self.names) == 0:
            print(self.incus(f'ls -c ns4t -f compact {self.project_prefix}'))
        else:
            for name, _, _ in self.name_iter(False):
                print(self.incus('ls -c ns4t -f compact'
                                 + f' {self.project_prefix}{name}$'))

    def cmd_ps(self):
        if len(self.names) == 0:
            self.use_all = True

        fullname_max = 0
        shortname_max = 0
        state_max = 0
        ipv4_max = 0
        state_dict = {}
        host_dict = {}
        ipv4_dict = {}
        shortname_dict = {}
        ls_info = self.incus_ls_info()
        for hostinfo in ls_info:
            host_dict[hostinfo['name']] = hostinfo
        for name, fullname, info in self.name_iter(self.use_all):
            shortname_dict[fullname] = name
            hostinfo = host_dict.get(fullname, None)
            if hostinfo is None:
                state = 'NOTCREATED'
            else:
                config = hostinfo.get('config', None)
                state = None
                if config is not None:
                    state = config.get('volatile.last_state.power', None)
                if state is None:
                    state = 'INITIALIZING'
            state_dict[fullname] = state
            net_if = self.convert_net_if('eth0', info)
            ipv4 = self.incus_get_ipv4(fullname, net_if, ls_info)
            if ipv4 is None:
                ipv4 = ''
            ipv4_dict[fullname] = ipv4
            fullname_len = len(fullname)
            if fullname_len > fullname_max:
                fullname_max = fullname_len
            shortname_len = len(name)
            if shortname_len > shortname_max:
                shortname_max = shortname_len
            state_len = len(state)
            if state_len > state_max:
                state_max = state_len
            ipv4_len = len(ipv4)
            if ipv4_len > ipv4_max:
                ipv4_max = ipv4_len
        for fullname, state in state_dict.items():
            print(f'{fullname:<{fullname_max}}'
                  + f' {shortname_dict[fullname]:<{shortname_max}}'
                  + f' {state:<{state_max}}'
                  + f' {ipv4_dict[fullname]:<{ipv4_max}}')

    def cmd_wait(self):
        for name, fullname, info in self.name_iter(self.use_all):
            self.incus_wait_for_wakeup(fullname, info)

    def cmd_shell(self):
        for name, fullname, info in self.name_iter(False):
            self.incus_wait_for_wakeup(fullname, info)
            args = [self.incus_command, 'exec', fullname]
            env = self.get_env(fullname)
            envkeys = []
            if env is not None:
                for k, v in env.items():
                    env_str = f'{k}={v}'
                    args += ['--env', env_str]
                    envkeys += [k]
            args += ['--']
            if not self.user_is_root:
                args += ['sudo', '-i', '-u', self.conf('/config/user')]
                if len(envkeys) > 0:
                    envkeys_str = ','.join(envkeys)
                    args += [f'--preserve-env={envkeys_str}']
            args += ['bash']
            self.logger.debug(pformat(args))
            proc = subprocess.Popen(
                args, shell=False, close_fds=True,
                stdin=None, stdout=None, stderr=None)
            proc.wait()
            break

    def cmd_exec(self):
        for name, fullname, info in self.name_iter(self.use_all):
            self.incus_exec(fullname, self.opt['<args>'],
                            user_is_root=self.user_is_root)

    def incus_create(self, info, name, fullname):
        if self.incus_command == 'lxc':
            image = info.get('image_lxd', None)
        else:
            image = None
        if image is None:
            image = info['image']
        args = ['init', image, fullname]
        for p in info.get('profile', {}):
            args += ['-p', self.project_prefix + p]
        for devname, params in info.get('devices', {}).items():
            kvlist = [devname]
            for key, val in params.items():
                kvlist.append(key + '=' + str(val))
            val = ','.join(kvlist)
            args += ['-d', val]

        # NOTE: NOT WORK:
        # Error: Cannot override config for device "volume_0":
        # Device not found in profile devices
        #
        # volume_list = info.get('volume', None)
        # if volume_list is not None:
        #     # /host|buildimage/NAME/volume : SRC:DST
        #     #   -> -d DEVNAME,type=disk,source=SRC,path=DST
        #     count = 0
        #     for volume_map in volume_list:
        #         device_name = f'volume_{count}'
        #         kvlist = [device_name]
        #         v = volume_map.split(':')
        #         src = self.convert_fullpath(v[0])
        #         dst = v[1]
        #         val = f'{device_name},type=disk,source={src},path={dst}'
        #         args += ['-d', val]
        #         count += 1

        for key, val in info.get('config', {}).items():
            args += ['-c', key + '=' + str(val)]
        idmap = self.conf('/config/idmap')
        idmap_uid = None
        self.logger.debug(f'idmap={idmap}')
        if str(idmap).isdigit():
            idmap_uid = str(idmap)
        elif self.tobool(idmap):
            idmap_uid = str(os.getuid())
        container_uid = self.conf('/config/uid')
        if idmap_uid is not None:
            args += ['-c', f'raw.idmap=both {idmap_uid} {container_uid}']
        if self.tobool(info['vm']):
            args += ['--vm']
        self.incus(args)

        if self.tobool(info['vm']) \
           and self.incus_cdrom_agent_is_required(fullname):
            # incus config device add INSTANCE \
            #   agent disk source=agent:config
            args2 = ['config', 'device', 'add', fullname,
                     'agent', 'disk', 'source=agent:config']
            self.incus(args2)

    def incus_cdrom_agent_is_required(self, fullname):
        # image.requirements.cdrom_agent for Incus VM
        # incus config get INSTANCE image.requirements.cdrom_agent
        args = ['config', 'get', fullname, 'image.requirements.cdrom_agent']
        b = self.incus(args, output=True).strip()
        self.logger.info(f'{fullname}: image.requirements.cdrom_agent={b}')
        return self.tobool(b)

    def mount_volume(self, fullname, info):
        # SEE ALSO: convert_disk_source()
        volume_list = info.get('volume', None)
        if volume_list is None:
            return
        # /host|buildimage/NAME/volume : SRC:DST
        #   -> -d DEVNAME,type=disk,source=SRC,path=DST
        count = 0
        for volume_map in volume_list:
            device_name = f'volume_{count}'
            v = volume_map.split(':')
            src = self.convert_fullpath(v[0])
            dst = v[1]
            self.incus(['config', 'device', 'add', fullname,
                        device_name, 'disk', f'source={src}', f'path={dst}'])
            count += 1

    def growpart(self, fullname):
        self.incus_exec(fullname,
                        'yum install -y e2fsprogs cloud-utils-growpart gdisk',
                        retry=5)
        mount = self.incus_exec(fullname, 'mount', output=True)
        device = None
        for line in mount.splitlines():
            fields = line.strip().split()
            if len(fields) >= 3 and fields[2] == "/":
                device = fields[0]
                break
        if device is not None:
            prefix = device.rstrip('0123456789')
            suffix = device[len(prefix):]
            self.incus_exec(fullname, f'growpart {prefix} {suffix}',
                            ignore_error=True)
            self.incus_exec(fullname, f'resize2fs {device}',
                            ignore_error=True)
            self.incus_exec(fullname, 'df -h')

    def use_sshd(self, info):
        return self.authorized_keys is not None \
            and self.tobool(info['sshd'])

    def install_sshd(self, info, name, fullname):
        if not self.use_sshd(info):
            self.logger.debug(f'{name}: sshd is not installed (disabled)')
            return
        if info['series'] == 'rhel':
            self.incus_exec(fullname, 'yum install -y openssh-server', retry=5)
            self.incus_exec(fullname, 'systemctl enable sshd')
            self.incus_exec(fullname, 'systemctl restart sshd')
        elif info['series'] == 'debian':
            self.incus_exec(fullname, 'apt-get update', retry=5)
            self.incus_exec(fullname, 'apt-get install -y openssh-server',
                            retry=5)
            self.incus_exec(fullname, 'systemctl enable ssh')
            self.incus_exec(fullname, 'systemctl restart ssh')

    def setup_user(self, info, fullname):
        user = self.conf('/config/user')
        uid = self.conf('/config/uid')
        # ignore: useradd: user 'incus' already exists
        self.incus_exec(fullname, 'useradd --create-home --shell /bin/bash'
                        + f' --uid {uid} {user}', ignore_error=True)
        homedir = self.incus_exec(fullname,
                                  ['su', user, 'sh', '-c',
                                   'echo $HOME'],
                                  output=True).strip()
        # sshdir=f'/home/{user}/.ssh'
        sshdir = homedir + '/.ssh'
        self.incus_exec(fullname, f'mkdir -p {sshdir}')
        # file copy
        if self.authorized_keys is not None:
            self.incus(['file', 'push', self.authorized_keys,
                        fullname + sshdir + '/authorized_keys'])
            self.incus_exec(fullname, f'chown -R {user}:{user} {sshdir}')
            self.incus_exec(fullname, f'chmod 700 {sshdir}')
            self.incus_exec(fullname, f'chmod 600 {sshdir}/authorized_keys')

        # if info['series'] == 'rhel':
        #     self.incus_exec(fullname, f'usermod -a -G wheel {user}')
        #     self.incus_exec(
        #         fullname,
        #         ['sed', '-i',
        #          '-e', '/%wheel[ \t]\\+ALL=(ALL)[ \t]\\+ALL/s/^/# /',
        #          '-e', '/%wheel[ \t]\\+ALL=(ALL)[ \t]\\+NOPASSWD:/s/^# //',
        #          '/etc/sudoers'])
        # elif info['series'] == 'debian':
        #     self.incus_exec(fullname, f'usermod -a -G sudo {user}')
        #     str_input = StringIO('%sudo   ALL=(ALL:ALL)  NOPASSWD: ALL')
        #     self.incus_exec(fullname, 'tee /etc/sudoers.d/group-sudo',
        #                     input=str_input, output=False)
        #     self.incus_exec(fullname, 'chmod 600 /etc/sudoers.d/group-sudo')
        sudoers = f'/etc/sudoers.d/{user}'
        str_input = StringIO(f'{user}   ALL=(ALL:ALL)  NOPASSWD: ALL')
        self.incus_exec(fullname, f'tee {sudoers}',
                        input=str_input, output=False)
        self.incus_exec(fullname, f'chmod 600 {sudoers}')

    def netconf_rhel(self, fullname, ifname, param, info):
        ipv4_address = param.get('ipv4.address')
        if ipv4_address is None:
            self.logger.debug(f'{ifname}: no static ipv4.address')
            return  # disabled ... not configure
        ipv4_gateway = param.get('ipv4.gateway')
        dns_list = param.get('dns')
        if dns_list is not None:
            dns = ','.join(dns_list)
        else:
            dns = None
        real_ifname = self.convert_net_if(ifname, info)

        lines = self.incus_exec(fullname,
                                'nmcli --fields UUID,DEVICE connection show',
                                output=True)
        uuid = None
        for line in lines.splitlines():
            self.logger.debug(f'nmcli outpuit: {line}')
            fields = line.strip().split()
            if fields[1] == real_ifname:
                uuid = fields[0]
        if uuid is None:
            self.logger.warning('cannot set static IP address')
            return

        # DO NOT add new connection
        # self.incus_exec(fullname,
        #                 'nmcli connection add type ethernet con-name'
        #         + f' {ifname} ifname {real_ifname}')
        self.incus_exec(fullname,
                        f'nmcli connection modify {uuid}'
                        + f' ipv4.method manual ipv4.addr {ipv4_address}')
        if ipv4_gateway is not None:
            self.incus_exec(fullname, 'nmcli connection modify '
                            + f'{uuid} ipv4.gateway {ipv4_gateway}')
        if dns is not None:
            self.incus_exec(fullname, 'nmcli connection modify'
                            + f' {uuid} ipv4.dns "{dns}"')

    def netconf_debian(self, fullname, ifname, param, info, netplan_dict):
        ipv4_address = param.get('ipv4.address')
        ipv4_gateway = param.get('ipv4.gateway')
        dns_list = param.get('dns')
        real_ifname = self.convert_net_if(ifname, info)

        if ipv4_address is not None:
            new_yaml = f'''network:
  version: 2
  ethernets:
    {real_ifname}:
      addresses:
        - {ipv4_address}
      dhcp4: false
      dhcp6: false
      accept-ra: false
      link-local: []
'''
            new_dict = yaml.safe_load(new_yaml)
            d2 = new_dict['network']['ethernets'][real_ifname]
            if ipv4_gateway is not None:
                d2['routes'] = [{'to': 'default', 'via': ipv4_gateway}]
            if dns_list is not None:
                d2['nameservers'] = {'addresses': dns_list}
        else:
            new_yaml = f'''network:
  version: 2
  ethernets:
    {real_ifname}:
      dhcp4: true
      dhcp6: true
'''
            new_dict = yaml.safe_load(new_yaml)
        self.deep_update(netplan_dict, new_dict, override=True)

    def setup_network_static(self, info, fullname):
        # configure static IP address
        netstatic = info.get('network-static', None)
        if netstatic is None:
            return

        if info['series'] == 'rhel':
            self.incus_exec(fullname, 'yum install -y NetworkManager', retry=5)
            self.incus_exec(fullname, 'systemctl enable NetworkManager')
            self.incus_exec(fullname, 'systemctl restart NetworkManager')
            for ifname, param in netstatic.items():
                self.netconf_rhel(fullname, ifname, param, info)
            self.incus_exec(fullname, 'systemctl restart NetworkManager')
        elif info['series'] == 'debian':
            netplan_dict = {
                # 'network': {
                #     'version': 2,
                #     'ethernets': {},
                # }
            }
            for ifname, param in netstatic.items():
                self.logger.debug(f'{fullname} {ifname} {str(param)}')
                self.netconf_debian(fullname, ifname, param,
                                    info, netplan_dict)
            netplan_path = '/etc/netplan/50-incus.yaml'
            self.incus_exec(fullname, f'touch {netplan_path}')
            self.incus_exec(fullname, f'chmod 600 {netplan_path}')
            str_input = StringIO(yaml.dump(netplan_dict, sort_keys=False))
            self.incus_exec(fullname, f'tee {netplan_path}', input=str_input)
            self.incus_exec(fullname, 'netplan apply')

    def update_etchosts(self, info, fullname):
        if not self.tobool(self.conf('/config/etchosts', default=True)):
            return  # disabled
        # backup and restore
        self.incus_exec(fullname, 'cp -n /etc/hosts /etc/hosts.orig',
                        ignore_error=True)
        self.incus_exec(fullname, 'cp -f /etc/hosts.orig /etc/hosts')
        etchosts = self.gen_etchosts()
        etchosts_str = '\n' + '\n'.join(etchosts) + '\n'
        self.incus_exec(fullname, 'tee -a /etc/hosts',
                        input=etchosts_str, output=False)

    def create_block_device(self, info, name, fullname):
        bd = info.get('block-device', None)
        if bd is None:
            return
        for bdname, params in bd.items():
            pool = params['pool']  # MUST
            # SEE ALSO: convert_disk_source()
            pool = self.convert_default_pool(pool)
            size = params['size']  # MUST
            if self.tobool(params.get('create', False)):  # default: False
                # True : re-create
                self.incus(f'storage volume delete {pool} {bdname}',
                           ignore_error=True)
                self.incus(f'storage volume create {pool} {bdname} '
                           + f'size={size} --type=block')
            self.incus(f'storage volume attach {pool} {bdname} {fullname}')

    def launch_common(self):
        for name, fullname, info in self.name_iter(self.use_all):
            if self.control_buildimage:
                # check required values (MUST)
                info['series']
            self.logger.info(f'[STEP-1] launch: {name}')
            self.incus_create(info, name, fullname)
            self.create_block_device(info, name, fullname)
            self.mount_volume(fullname, info)
            self.incus_start(fullname)

        for name, fullname, info in self.name_iter(self.use_all):
            self.logger.info(f'[STEP-2] initialize network and volume: {name}')
            self.incus_wait_for_wakeup(fullname, info)
            self.setup_network_static(info, fullname)

        for name, fullname, info in self.name_iter(self.use_all):
            if self.tobool(info['vm']):
                # VM may fail to mount volumes
                self.logger.info(f'[STEP-2.B] restart: {name}')
                self.incus_wait_for_wakeup(fullname, info)
                # self.incus(f'restart {fullname}')
                self.incus_stop(fullname)
                self.incus_start(fullname)

        for name, fullname, info in self.name_iter(self.use_all):
            if self.tobool(info['vm']):
                self.incus_wait_for_wakeup(fullname, info)
            self.logger.info(f'[STEP-3] setup: {name}')
            if self.tobool(info['vm']) and info['series'] == 'rhel':
                # growpart for rhel VM
                self.logger.info(f'[STEP-3.A] growpart: {name}')
                self.growpart(fullname)
            self.setup_user(info, fullname)
            self.incus_exec(fullname, 'systemctl restart systemd-hostnamed')
            self.incus_exec(fullname, f'hostnamectl set-hostname {name}')
            if not self.control_buildimage:
                self.logger.info(f'[STEP-3.B] sshd: {name}')
                self.install_sshd(info, name, fullname)
                self.update_etchosts(info, fullname)

            # run /host|buildimage/NAME/setup
            for cmd in info.get('setup', []):
                if cmd == '__RESTART__':
                    self.logger.info(f'[STEP-3.C] setup(__RESTART__): {name}')
                    self.incus_stop(fullname)
                    self.incus_start(fullname)
                    self.incus_wait_for_wakeup(fullname, info)
                else:
                    self.logger.info(f'[STEP-3.D] setup(str(cmd)): {name}')
                    self.incus_exec(fullname, cmd, user_is_root=False)

            if self.control_buildimage:
                self.logger.info(f'[STEP-3.E] publish image: {name}')
                self.incus_stop(fullname)
                # publish buildimage
                aliases = info.get('publish-alias', None)
                if aliases is None or len(aliases) == 0:
                    self.logger.info('not published (no publish-alias): '
                                     + f'{name}')
                else:
                    remotes = info.get('publish-remote', None)

                    def publish(remote):
                        args = ['publish', fullname]
                        if remote is not None:
                            args.append(remote + ':')
                        for alias in aliases:
                            full_alias = self.project_prefix + alias
                            self.incus(['image', 'delete', full_alias],
                                       ignore_error=True)
                            args.extend(['--alias', full_alias])
                        self.incus(args)
                        if self.tobool(info['vm']) \
                           and self.incus_cdrom_agent_is_required(fullname):
                            full_alias = self.project_prefix + aliases[0]
                            self.set_cdrom_agent(remote, full_alias, True)

                    if remotes is None:
                        publish(None)
                    else:
                        for remote in remotes:
                            publish(remote)

    def set_cdrom_agent(self, remote, full_alias, bool_val):
        if remote is not None and remote != '':
            remote = f'{remote}:'
        else:
            remote = ''
        image_name = f'{remote}{full_alias}'
        self.incus(['image', 'set-property', image_name,
                    'requirements.cdrom_agent', str(bool_val).lower()])

    def cmd_build(self):
        self.control_buildimage = True
        self.cmd_stop()
        self.cmd_delete()
        self.launch_common()

    def cmd_launch(self):
        self.control_buildimage = False
        self.launch_common()


if __name__ == '__main__':
    IncusAuto(program_name).main()
