#!/usr/bin/env python3

# Requirements:
# --- for Debian,Ubuntu series ---
# apt-get install python3 python3-docopt python3-schema python3-yaml
#
# --- for RHEL,CentOS series ---
# yum install     epel-release
# yum install     python3 python3-docopt python3-schema python3-pyyaml
#
# --- Or, install to ~/.local just for user's environment ---
# (required: python3-pip)
# pip3 install --user docopt schema PyYAML
#
# Coding style check:
# flake8 ./incus-auto

import os
import logging
import subprocess
import json
from pprint import pprint, pformat
from io import StringIO

from docopt import docopt
from schema import Schema, Or
import yaml

program_name = os.path.basename(__file__)

__doc__ = """
Automating deployment system by Incus or LXD.

Usage:
  {f} init [options]
  {f} ls [options]
  {f} ps [options]
  {f} <command> <name>... [options]
  {f} <command> --all [options]

Options:
  --all                     all images or all instances
  -f, --file=FILE           configuration YAML file
                            [default: incus-auto.yaml]
  -l, --loglevel=LEVEL      log level (debug, info, warning, error)
                            [default: debug]
  --encoding=CODEC          codec for filename encoding
          (https://docs.python.org/3/library/codecs.html#standard-encodings)
                            [default: utf-8]
  -?, -h, --help            show this help and exit

Command:
  init       initialize profile and network
  build      build images
  launch     launch hosts
  ps         list status of hosts
  ls         list hosts by `incus list` command
  stop       stop hosts
  start      start hosts
  restart    restart hosts
  delete     delete stopped hosts, profile and network
""".format(f=program_name)

_schema = Schema({
    '--all': bool,
    '--file': str,
    '--loglevel': str,
    '--encoding': str,
    '--help': bool,
    '<command>': Or(str, None),
    'init': bool,
    'ls': bool,
    'ps': bool,
    '<name>': [str],
})


class CUI():
    def cui_init(self, program_name):
        self.program_name = program_name
        self._docopt = docopt(self.getDoc())
        # pprint(self._docopt)  # for debug
        self.opt = self.getSchema().validate(self._docopt)
        self.loglevel_str = self.opt['--loglevel']

        loglevel_dict = {
            'debug': logging.DEBUG,
            'info': logging.INFO,
            'warning': logging.WARNING,
            'error': logging.ERROR,
        }
        self.loglevel = loglevel_dict[self.loglevel_str.lower()]
        # use stderr
        self.logger = self.logger_init()

    def logger_init(self):
        logger = logging.getLogger()  # RootLogger
        logger.setLevel(self.loglevel)
        stream = logging.StreamHandler()  # stderr
        if self.loglevel == logging.DEBUG:
            fmt = '%(filename)s:%(levelname)s:L%(lineno)d:' + \
                '%(asctime)s: %(message)s'
            fmt = fmt.format(self.program_name)
        elif self.loglevel == logging.INFO:
            fmt = '{}:%(levelname)s: %(message)s'.format(self.program_name)
        else:
            fmt = '%(message)s'
        formatter_stream = logging.Formatter(fmt=fmt, datefmt='%Y%m%d%H%M%S')
        stream.setFormatter(formatter_stream)
        stream.setLevel(self.loglevel)
        logger.addHandler(stream)
        return logger

    def getDoc(self):
        raise NotImplementedError

    def getSchema(self):
        raise NotImplementedError

    def run(self):
        raise NotImplementedError

    def execv(self, args, stdin=None, timeout=None, textmode=False):
        out, err, ret = self.execv_raw(args, stdin, timeout, textmode)
        if textmode:
            err = err.rstrip()
        else:
            try:
                err = err.decode().rstrip()
            except Exception:
                self.logger.debug('cannot decode: err=%s', err)
        if ret != 0:
            msg = '{}: {}'.format(str(args), err)
            if err:
                self.logger.debug(msg)
                raise Exception(msg)
        if err:
            self.logger.info(err)
        return out

    def execv_raw(self, args, stdin=None,
                  timeout=None, textmode=False):
        self.logger.debug('Popen(args=%s)', str(args))
        if textmode:
            encoding = self.encoding
        else:
            encoding = None
        proc = subprocess.Popen(
            args, shell=False, encoding=encoding, close_fds=True,
            stdin=subprocess.PIPE, stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        try:
            if stdin is not None:
                out, err = proc.communicate(stdin.read(), timeout=timeout)
            else:
                out, err = proc.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            proc.kill()
            out, err = proc.communicate()
        ret = proc.wait()
        return out, err, ret


class IncusAuto(CUI):
    def __init__(self, program_name):
        self.cui_init(program_name)
        self.parse_opt()
        self.change_dir()
        self.load_conf()

    def getDoc(self):
        return __doc__

    def getSchema(self):
        return _schema

    def parse_opt(self):
        self.names = self.opt['<name>']
        self.use_all = self.opt['--all']
        self.conf_file = self.opt['--file']
        self.encoding = self.opt['--encoding']

    def change_dir(self):
        print(self.conf_file)
        os.chdir(os.path.dirname(os.path.abspath(self.conf_file)))

    def set_default(self, base_dict, defaults):
        def common(base, key, val):
            base_val = base.get(key, None)
            if isinstance(val, dict):
                if base_val is None:
                    base[key] = {}
                self.set_default(base[key], val)
            elif base_val is None:
                base[key] = val

        for k, v in defaults.items():
            if k == '__ANY__':
                for k2 in list(base_dict.keys()):
                    common(base_dict, k2, v)
            else:
                common(base_dict, k, v)

    def load_conf(self):
        with open(self.conf_file) as f:
            self.conf_dict = yaml.safe_load(f)
        self.logger.debug(pformat(self.opt))
        self.logger.debug(pformat(self.conf_dict))

        # TODO
        config_defaults = {
            'config': {
                'incus_command': 'incus',
            },
            'host': {
                '__ANY__': {
                    'disk': '5GB',
                }
            }
        }
        self.set_default(self.conf_dict, config_defaults)
        self.logger.debug(pformat(self.conf_dict))

        self.project_prefix = self.conf('/config/project') + '-'
        self.host_all = self.conf('/host').keys()

    def conf(self, confpath):
        return self.dictpath(self.conf_dict, confpath)

    @classmethod
    def dictpath(cls, d, dpath):
        if isinstance(dpath, list):
            keys = dpath
        else:
            keys = [key for key in dpath.split('/') if key]
        result = d
        for key in keys:
            try:
                result = result[key]
            except (KeyError, TypeError):
                return None
        return result

    def is_defined_host(self, hostname):
        return hostname in self.host_all

    def check_defined_host(self, hostname):
        if not self.is_defined_host(hostname):
            raise Exception(f'Undefined host: {hostname}')

    def incus(self, args, stdin=None):
        if isinstance(args, str):
            args = args.split()
        args = [self.conf('/config/incus_command')] + args
        return self.execv(args, textmode=True, stdin=stdin)

    def execute(self):
        commands = {
            'init': self.init,
            'ls': self.ls,
            'ps': self.ps,
            'build': self.build,
            'launch': self.launch,
            'delete': self.delete,
        }
        # execute method
        if self.opt['init']:
            commands['init']()
        elif self.opt['ls']:
            commands['ls']()
        elif self.opt['ps']:
            commands['ps']()
        else:
            commands[self.opt['<command>']]()

    def init(self):
        # create networks
        for netname in self.conf('/config/network').keys():
            self.incus(f'network create {netname}')
            d = self.conf(['config', 'network', netname])
            ystr = yaml.dump(d)
            self.logger.debug(ystr)
            strio = StringIO(ystr)
            self.incus(f'network edit {netname}', stdin=strio)
            self.logger.info(f'network: "{netname}" created')
        # create profiles
        for profname in self.conf('/config/profile').keys():
            self.incus(f'profile create {profname}')
            d = self.conf(['config', 'profile', profname])
            ystr = yaml.dump(d)
            self.logger.debug(ystr)
            strio = StringIO(ystr)
            self.incus(f'profile edit {profname}', stdin=strio)
            self.logger.info(f'profile: "{profname}" created')

    def delete(self):
        if self.use_all:
            # delete hosts
            for hostname in self.host_all:
                try:
                    self.incus(f'delete {hostname}')
                    self.logger.info(f'host: "{hostname}" deleted')
                except Exception as e:
                    self.logger.info('Ignored: %s', str(e))  #TODO debug?
            # delete profiles
            for profname in self.conf('/config/profile').keys():
                try:
                    self.incus(f'profile delete {profname}')
                    self.logger.info(f'profile: "{profname}" deleted')
                except Exception as e:
                    self.logger.info('Ignored: %s', str(e))
            # delete networks
            for netname in self.conf('/config/network').keys():
                try:
                    self.incus(f'network delete {netname}')
                    self.logger.info(f'network: "{netname}" deleted')
                except Exception as e:
                    self.logger.info('Ignored: %s', str(e))
        else:
            # delete specified hosts only
            for hostname in self.names:
                self.check_defined_host(hostname)
            for hostname in self.names:
                try:
                    self.incus(f'delete {hostname}')
                    self.logger.info(f'host: "{hostname}" deleted')
                except Exception as e:
                    self.logger.info('Ignored: %s', str(e))

    def ls(self):
        if self.use_all or len(self.names) == 0:
            print(self.incus(f'ls -c ns4t {self.conf("/config/project")}-'))
        else:
            for name in self.names:
                self.check_defined_host(name)
            for name in self.names:
                print(self.incus(f'ls -c ns4t {self.conf("/config/project")}-{name}$'))

    def ps(self):
        state_dict = {}
        host_max = 0
        state_max = 0
        if self.use_all or len(self.names) == 0:
            names = self.host_all
        else:
            names = self.names
            for name in names:
                self.check_defined_host(name)

        j_str = self.incus('ls -f json')
        j = json.loads(j_str)
        host_dict = {}
        for hostinfo in j:
            host_dict[hostinfo['name']] = hostinfo
        for name in names:
            host = self.project_prefix + name
            hostinfo = host_dict.get(host, None)
            if hostinfo is None:
                state = "NOTCREATED"
            else:
                state = hostinfo['config']['volatile.last_state.power']
            state_dict[host] = state
            host_len = len(host)
            if host_len > host_max:
                host_max = host_len
            state_len = len(state)
            if state_len > state_max:
                state_max = state_len
        for host, state in state_dict.items():
            print(f'{host:<{host_max}}  {state:<{state_max}}')

    def build(self):
        # build images and publish to remote
        for imagename in self.conf('/build').keys():
            info = self.conf(['build', imagename])
            print(imagename)
            print(info['image'])
            #self.incus(f'launch {info['image']})
        # TODO
        pass

    def launch(self):
        # TODO
        pass

if __name__ == '__main__':
    IncusAuto(program_name).execute()
