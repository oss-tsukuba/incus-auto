#!/usr/bin/env python3

# Requirements:
# --- for Debian,Ubuntu series ---
# apt-get install python3 python3-docopt python3-schema python3-yaml
#
# --- for RHEL,CentOS series ---
# yum install     epel-release
# yum install     python3 python3-docopt python3-schema python3-pyyaml
#
# --- Or, install to ~/.local just for user's environment ---
# (required: python3-pip)
# pip3 install --user docopt schema PyYAML
#
# Coding style check:
# flake8 ./incus-auto

import os
import logging
import subprocess
import json
from pprint import pformat
from io import StringIO
import time
import inspect
import shlex

from docopt import docopt
from schema import Schema, Or
import yaml

program_name = os.path.basename(__file__)

# TODO {f} delete-block

__doc__ = """
Automating deployment system by Incus or LXD.

Usage:
  {f} init [options]
  {f} destroy [options]
  {f} ls [options]
  {f} ps [options]
  {f} shell <name> [--root] [options]
  {f} exec <name> [--root] [options] [--] <args>...
  {f} exec --all [--root] [options] [--] <args>...
  {f} config [options]
  {f} ansible-inventory [options]
  {f} etchosts [options]
  {f} <command> <name> [options]
  {f} <command> --all [options]

Options:
  -a, --all                 all buildimages or all hosts
  -b, --buildimage          control buildimages
  -f, --file=FILE           configuration file (YAML)
                            [default: incus-auto.yaml]
  -o, --override=FILE       override configuration file (if it exists)
                            [default: incus-auto.override.yaml]
  --root                    execute by root
  -l, --loglevel=LEVEL      log level (debug, info, warning, error)
                            [default: info]
  --encoding=CODEC          codec for filename encoding
          (https://docs.python.org/3/library/codecs.html#standard-encodings)
                            [default: utf-8]
  -?, -h, --help            show this help and exit

Command:
  init               initialize networks, profiles and buildimages
  destroy            destroy buildimages, profiles and networks
  build              (re)build images
  launch             launch hosts
  ps                 list status of hosts
  ls                 list hosts by `incus list` command
  shell              open shell
  exec               execute command
  config             check and show configuration parameters
  ansible-inventory  for ansible-inventory -i -
  etchosts           print list for /etc/hosts
  update-etchosts    update /etc/hosts for hosts
  stop               stop hosts
  start              start hosts
  restart            restart hosts
  delete             delete stopped hosts, profile and network

Multiple targets:
  Example:
    {f} exec host1,host2 hostname
""".format(f=program_name)

opt_schema = Schema({
    '--all': bool,
    '--buildimage': bool,
    '--root': bool,
    '--file': str,
    '--override': str,
    '--loglevel': str,
    '--encoding': str,
    '--help': bool,
    '<command>': Or(str, None),
    'init': bool,
    'destroy': bool,
    'ls': bool,
    'ps': bool,
    'shell': bool,
    'exec': bool,
    'config': bool,
    'ansible-inventory': bool,
    'etchosts': bool,
    '<name>': Or(str, None),
    '<args>': [str],
    '--': bool,
})


class CUI():
    def cui_init(self, program_name):
        self.program_name = program_name
        self._docopt = docopt(self.get_doc())
        self.opt = self.get_opt_schema().validate(self._docopt)
        self.loglevel_str = self.opt['--loglevel']

        loglevel_dict = {
            'debug': logging.DEBUG,
            'info': logging.INFO,
            'warning': logging.WARNING,
            'error': logging.ERROR,
        }
        self.loglevel = loglevel_dict[self.loglevel_str.lower()]
        # use stderr
        self.logger = self.logger_init()

    def logger_init(self):
        logger = logging.getLogger()  # RootLogger
        logger.setLevel(self.loglevel)
        stream = logging.StreamHandler()  # stderr
        if self.loglevel == logging.DEBUG:
            fmt = '%(filename)s:%(levelname)s:L%(lineno)d:' + \
                '%(asctime)s: %(message)s'
            fmt = fmt.format(self.program_name)
        elif self.loglevel == logging.INFO:
            fmt = '{}: %(message)s'.format(self.program_name)
        else:
            fmt = '%(message)s'
        formatter_stream = logging.Formatter(fmt=fmt, datefmt='%Y%m%d%H%M%S')
        stream.setFormatter(formatter_stream)
        stream.setLevel(self.loglevel)
        logger.addHandler(stream)
        return logger

    def get_doc(self):
        raise NotImplementedError

    def get_opt_chema(self):
        raise NotImplementedError

    def run(self):
        raise NotImplementedError

    def execv(self, args, input=None, output=None,
              timeout=None, textmode=False, ignore_error=False):
        if isinstance(args, str):
            # ex. shlex.split('a b "c d" \\"e')
            #     -> ['a', 'b', 'c d', '"e']
            args = shlex.split(args)
        out, err, ret = self.execv_raw(args, input=input, output=output,
                                       timeout=timeout, textmode=textmode)
        if textmode:
            err = err.rstrip()
        else:
            try:
                err = err.decode().rstrip()
            except Exception:
                self.logger.debug('cannot decode: err=%s', err)
        if ret != 0:
            msg = f'{str(args)}: {str(err)}'
            if ignore_error:
                self.logger.info('Error ignored: ' + msg)
                return
            else:
                raise Exception('Error: ' + msg)
        if err:
            self.logger.info(err)
        self.logger.debug(f'Success: {str(args)}')
        return out

    def execv_raw(self, args, input=None, output=None,
                  timeout=None, textmode=False):
        # input:
        #   read()able stream object
        #   False: disable(/dev/null)
        #   None: read from stdin
        # output:
        #   True: use PIPE (return out, err)
        #   False: disable(/dev/null)
        #   None: write to stdout and stderr directly
        if textmode:
            encoding = self.encoding
        else:
            encoding = None
        if input is None:
            stdin = None
        elif input is False:
            stdin = subprocess.DEVNULL
        else:  # stream
            stdin = subprocess.PIPE
        if output is None:
            stdout = None
        elif output:
            stdout = subprocess.PIPE
        else:
            stdout = subprocess.DEVNULL
        # self.logger.debug('Popen(args=%s)', str(args))
        proc = subprocess.Popen(
            args, shell=False, encoding=encoding, close_fds=True,
            stdin=stdin, stdout=stdout, stderr=stdout)
        try:
            if input is not None:
                out, err = proc.communicate(input.read(), timeout=timeout)
            else:
                out, err = proc.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            proc.kill()
            out, err = proc.communicate()
        ret = proc.wait()
        if out is None:
            out = ''
        if err is None:
            err = ''
        return out, err, ret

    @classmethod
    def dictpath(cls, d, dpath):
        if isinstance(dpath, list):
            keys = dpath
        else:
            keys = [key for key in dpath.split('/') if key]
        result = d
        for key in keys:
            try:
                result = result[key]
            except (KeyError, TypeError):
                return None
        return result

    @classmethod
    def tobool(cls, s):
        if isinstance(s, bool):
            return s
        return s.lower() in ['true', 'yes', 'on', 'enable']


class IncusAuto(CUI):
    def __init__(self, program_name):
        self.cui_init(program_name)
        self.parse_opt()
        self.change_dir()
        self.load_conf()
        self.check_required()

    def get_doc(self):
        return __doc__

    def get_opt_schema(self):
        return opt_schema

    def parse_opt(self):
        name = self.opt['<name>']
        if name is not None:
            self.names = name.split(',')
        else:
            self.names = []
        self.use_all = self.opt['--all']  # CANNOT be changed outside of cmd_*
        self.control_buildimage = self.opt['--buildimage']
        self.conf_file = self.opt['--file']
        self.override_file = self.opt['--override']
        self.encoding = self.opt['--encoding']
        self.user_is_root = self.opt['--root']

    def change_dir(self):
        self.basedir = os.path.realpath(os.path.dirname(self.conf_file))
        os.chdir(self.basedir)

    @classmethod
    def deep_update(cls, dst, src, override=False):
        def update_common(target, key, val):
            target_val = target.get(key, None)
            if isinstance(val, dict):
                if target_val is None:
                    target[key] = {}
                cls.deep_update(target[key], val, override)
            elif override or target_val is None:
                target[key] = val

        for k, v in src.items():
            if k == '__ANY__':
                for k2 in list(dst.keys()):
                    update_common(dst, k2, v)
            else:
                update_common(dst, k, v)

    def pformat(self, obj):
        if not hasattr(self, '_pformat_has_sort_dicts'):
            pformat_kwargs = inspect.getfullargspec(pformat).kwonlyargs
            self.logger.debug(f'pformat_kwargs={str(pformat_kwargs)}')
            # NOTE: Changed in Python 3.8: Added the sort_dicts parameter.
            if 'sort_dicts' in pformat_kwargs:
                self._pformat_has_sort_dicts = True
            else:
                self._pformat_has_sort_dicts = False
        if self._pformat_has_sort_dicts:
            return pformat(obj, sort_dicts=False)
        else:
            return pformat(obj)

    def load_conf(self):
        self.logger.debug(self.pformat(self.opt))
        with open(self.conf_file) as f:
            self.conf_dict = yaml.safe_load(f)
        self.logger.debug(self.conf_file + ' (original): '
                          + self.pformat(self.conf_dict))
        if os.path.exists(self.override_file):
            with open(self.override_file) as f:
                override_dict = yaml.safe_load(f)
                self.deep_update(self.conf_dict, override_dict, override=True)
            self.logger.debug(self.override_file + ' (override): '
                              + self.pformat(self.conf_dict))

        # TODO set defaults
        config_defaults = {
            'config': {
                'incus_command': 'incus',
                'idmap': False,
                'user': 'admin',  # main guest user
                'uid': 2000,
                'ssh_authorized_keys': 'ssh_authorized_keys',
                'etchosts': True,
            },
            'buildimage': {
                '__ANY__': {
                    'vm': False,
                    'devices': {
                        # 'root': {
                        #     'size': '5GB',
                        # },
                    },
                },
            },
            'host': {
                '__ANY__': {
                    'vm': False,
                    'devices': {
                        # 'root': {
                        #     'size': '5GB',
                        # },
                    },
                },
            },
        }
        self.deep_update(self.conf_dict, config_defaults)
        self.logger.debug('self.conf_dict (set defaults): '
                          + self.pformat(self.conf_dict))

        for name in self.conf('/buildimage').keys():
            if self.is_defined(name, '/host'):
                raise Exception(
                    'Error: buildimage and host cannot be duplicated: ' + name)
        self.project_prefix = self.conf('/config/project') + '-'
        self.incus_command = self.conf('/config/incus_command')
        self.stop_timeout = 60

    def check_required(self):
        self.authorized_keys = self.convert_fullpath(
            self.conf('/config/ssh_authorized_keys'))
        if not os.access(self.authorized_keys, os.R_OK):
            raise Exception(f'Error: cannot read: {self.authorized_keys}')

    def conf(self, confpath, default=None, notfound=False):
        result = self.dictpath(self.conf_dict, confpath)
        if result is None:
            if notfound:
                raise Exception(f'incus-auto.yaml: {confpath}: not defined')
            return default
        return result

    def depend_name_sort(self, d):
        limit = len(d.keys())

        def depth(name, n):
            max_dep = n
            if max_dep >= limit:
                self.logger.debug(f'depth({name}, {n}): {max_dep} LIMIT')
                return max_dep
            info = d.get(name, None)
            if info is None:
                return max_dep
            depends = info.get('depend', None)
            if depends is None:
                return max_dep
            if isinstance(depends, str):
                depends = depends.split(',')
            for item in depends:
                tmp = depth(item, n+1)
                if tmp > max_dep:
                    max_dep = tmp
            self.logger.debug(f'depth({name}, {n}): {max_dep}')
            return max_dep

        def custom_key(name):
            self.logger.debug(f'depend_name_sort: {name}: start')
            dep = depth(name, 0)
            self.logger.debug(f'depend_name_sort: {name}: result={dep}')
            return dep

        return sorted(d.keys(), key=custom_key)

    def name_iter(self, use_all):
        if self.control_buildimage:
            target_path = '/buildimage'
        else:
            target_path = '/host'
        d = self.conf(target_path)
        if use_all:
            for name in self.depend_name_sort(d):
                yield (name, self.project_prefix + name, d[name])
        else:  # specified hosts
            target_dict = {}
            for name in self.names:
                target_dict[name] = d[name]
            for name in self.depend_name_sort(target_dict):
                self.check_defined(name, target_path)
                yield (name, self.project_prefix + name, d[name])

    def is_defined(self, name, dpath):
        return name in self.conf(dpath).keys()

    def check_defined(self, name, dpath):
        if not self.is_defined(name, dpath):
            raise Exception(f'Undefined {dpath}: {name}')

    def incus(self, args, input=None, output=None, ignore_error=False):
        if isinstance(args, str):
            args = shlex.split(args)
        if isinstance(input, str):
            input = StringIO(input)
        args = [self.incus_command] + args
        return self.execv(args, textmode=True, input=input, output=output,
                          ignore_error=ignore_error)

    def fullname_to_shortname(self, fullname):
        return fullname[len(self.project_prefix):]

    def get_env(self, fullname):
        name = self.fullname_to_shortname(fullname)
        envvar1 = self.conf('/config/envvar')
        if self.control_buildimage:
            envvar2 = self.conf(f'/buildimage/{name}/envvar')
        else:
            envvar2 = self.conf(f'/host/{name}/envvar')
        if envvar1 is not None:  # dict
            if envvar2 is not None:
                self.deep_update(envvar1, envvar2, override=True)
                return envvar1
            else:
                return envvar1
        else:
            return envvar2

    def incus_exec(self, fullname, args, user_is_root=True,
                   input=None, output=None, ignore_error=False):
        fullargs = ['exec', fullname]
        env = self.get_env(fullname)
        self.logger.debug('envvar: \n' + pformat(env))
        envkeys = []
        if env is not None:
            for k, v in env.items():
                env_str = f'{k}={v}'
                fullargs += ['--env', env_str]
                envkeys += [k]
        fullargs += ['--']
        if not user_is_root:
            envkeys_str = ','.join(envkeys)
            fullargs += ['sudo', '-i', f'--preserve-env={envkeys_str}',
                         '-u', self.conf('/config/user')]
        if isinstance(args, str):
            args = shlex.split(args)
        fullargs += args
        return self.incus(fullargs, input=input, output=output,
                          ignore_error=ignore_error)

    def incus_ls_json(self):
        j_str = self.incus('ls -f json', output=True)
        return json.loads(j_str)

    def incus_is_running(self, name):
        try:
            self.incus(['exec', name, 'hostname'], output=False)
            return True
        except Exception:
            return False

    def convert_net_if(self, net_if, info):
        if not self.tobool(info['vm']):
            return net_if
        table = {
            'eth0': 'enp5s0',
            'eth1': 'enp6s0',
        }
        return table[net_if]

    def incus_wait_for_wakeup(self, name, info):
        net_if = self.convert_net_if('eth0', info)
        first = True
        while not self.incus_is_running(name):
            if first or self.loglevel == logging.DEBUG:
                self.logger.info(f'Waiting for startup: {name}')
                first = False
            else:
                print('.', end='', flush=True)
            time.sleep(1)
        if not first:
            print('OK')
        first = True
        while self.incus_get_ipv4(name, net_if) is None:
            if first or self.loglevel == logging.DEBUG:
                self.logger.info(f'Waiting until seeing IP address: {name}')
            else:
                print('.', end='', flush=True)
            time.sleep(1)
        if not first:
            print('OK')

    def incus_get_ipv4(self, name, net_if):
        for hostinfo in self.incus_ls_json():
            if name != hostinfo['name']:
                continue
            addresses = self.dictpath(
                hostinfo, ['state', 'network', net_if, 'addresses'])
            if addresses is None:
                break
            for a in addresses:
                if a.get('family') == 'inet' \
                   and a.get('address', None) is not None:
                    return a['address']
            break
        return None

    def convert_fullpath(self, path):
        if path is None:
            return None
        if path.startswith('/'):
            return path
        return os.path.join(self.basedir, path)

    def convert_disk_source(self, devices):
        for device, params in devices.items():
            if params.get('type') == 'disk':
                source = params.get('source', None)
                fullpath = self.convert_fullpath(source)
                if fullpath is not None:
                    self.logger.debug("source: fullpath=" + str(fullpath))
                    devices[device]['source'] = fullpath
        return devices

    def incus_each(self, cmd, args=[], build=False, ignore_error=False):
        if build:
            self.control_buildimage = build
        for name, fullname, info in self.name_iter(self.use_all):
            print(f'{self.incus_command} {cmd} {fullname}')
            self.incus([cmd, fullname] + args,
                       ignore_error=ignore_error,
                       output=True)  # err in Exception

    def main(self):
        commands = {
            'init': self.cmd_init,
            'destroy': self.cmd_destroy,
            'ls': self.cmd_ls,
            'ps': self.cmd_ps,
            'shell': self.cmd_shell,
            'exec': self.cmd_exec,
            'config': self.cmd_config,
            'ansible-inventory': self.cmd_ansible_inventory,
            'etchosts': self.cmd_etchosts,
            'update-etchosts': self.cmd_update_etchosts,
            'build': self.cmd_build,
            'launch': self.cmd_launch,
            'start': self.cmd_start,
            'restart': self.cmd_restart,
            'stop': self.cmd_stop,
            'delete': self.cmd_delete,
        }
        simple_commands = ['init',
                           'destroy',
                           'ls',
                           'ps',
                           'shell',
                           'exec',
                           'config',
                           'ansible-inventory',
                           'etchosts',
                           ]
        cmd_name = None
        for n in simple_commands:
            if self.opt[n]:
                cmd_name = n
                break
        if cmd_name is None:
            cmd_name = self.opt['<command>']
        # execute method
        commands[cmd_name]()

    def cmd_config(self):
        print(yaml.dump(self.conf_dict, sort_keys=False))

    def conf_get_ipv4(self, name):
        ip = self.conf(f'/host/{name}/network-static/eth0/ipv4.address')
        if ip is None:
            ip = self.conf(f'/host/{name}/devices/eth0/ipv4.address')
        if ip is None:
            return None
        return ip.split('/')[0]

    def cmd_ansible_inventory(self):
        hosts = {}
        user = self.conf('/config/user')
        for name, fullname, info in self.name_iter(True):
            ip = self.conf_get_ipv4(name)
            if ip is None:
                ip = name
            hosts[name] = {
                'ansible_host': ip,
                'ansible_user': user,
            }
        inv = {}
        inv[self.conf('/config/project')] = {'hosts': hosts}
        print(yaml.dump(inv, sort_keys=False))

    def gen_etchosts(self):
        hosts = []
        for name, fullname, info in self.name_iter(True):
            ip = self.conf_get_ipv4(name)
            if ip is None:
                continue  # skip
            # aliases
            alt = self.conf(f'/host/{name}/alternative')
            alt_str = ''
            if alt is not None:
                alt_str = ' ' + ' '.join(alt)
            hosts.append(f'{ip}    {name} {fullname}{alt_str}')
        return hosts

    def cmd_etchosts(self):
        self.use_all = True
        for host in self.gen_etchosts():
            print(host)

    def cmd_init(self):
        # create networks
        for netname in self.conf('/config/network').keys():
            self.incus(f'network create {netname}')
            d = self.conf(['config', 'network', netname])
            ystr = yaml.dump(d, sort_keys=False)
            self.logger.debug(ystr)
            str_input = StringIO(ystr)
            self.incus(f'network edit {netname}', input=str_input)
            self.logger.info(f'network: "{netname}" created')
            self.incus(f'network show {netname}')
        # create profiles
        for profname in self.conf('/config/profile').keys():
            fullname = self.project_prefix + profname
            self.incus(f'profile create {fullname}')
            d = self.conf(['config', 'profile', profname])
            devices = d.get('devices', None)
            if devices is not None:
                d['devices'] = self.convert_disk_source(devices)
            ystr = yaml.dump(d, sort_keys=False)
            self.logger.debug(ystr)
            str_input = StringIO(ystr)
            self.incus(f'profile edit {fullname}', input=str_input)
            self.logger.info(f'profile: "{fullname}" created')
            self.incus(f'profile show {fullname}')
        # create buildimages
        self.use_all = True
        self.cmd_build()

    def cmd_destroy(self):
        # delete buildimages
        self.use_all = True
        # self.incus_each('stop', ['-f'], build=True, ignore_error=True)
        self.incus_each('delete', ['-f'], build=True, ignore_error=True)
        # delete profiles
        for profname in self.conf('/config/profile').keys():
            fullname = self.project_prefix + profname
            self.incus(f'profile delete {fullname}', ignore_error=True,
                       output=True)
        # delete networks
        for netname in self.conf('/config/network').keys():
            self.incus(f'network delete {netname}', ignore_error=True,
                       output=True)

    def cmd_start(self):
        self.incus_each('start', ['--verbose'],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_restart(self):
        self.incus_each('restart', ['--verbose',
                                    '--timeout', str(self.stop_timeout)],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_stop(self):
        self.incus_each('stop', ['--verbose',
                                 '--timeout', str(self.stop_timeout)],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_delete(self):
        self.incus_each('delete', ['--verbose'],
                        build=self.control_buildimage, ignore_error=True)

    def cmd_update_etchosts(self):
        for name, fullname, info in self.name_iter(self.use_all):
            print(f'update /etc/hosts: {name}')
            self.update_etchosts(info, fullname)

    def cmd_ls(self):
        if self.use_all or len(self.names) == 0:
            print(self.incus(f'ls -c ns4t -f compact {self.project_prefix}'))
        else:
            for name, _, _ in self.name_iter(False):
                print(self.incus('ls -c ns4t -f compact'
                                 + f' {self.project_prefix}{name}$'))

    def cmd_ps(self):
        if len(self.names) == 0:
            self.use_all = True

        state_dict = {}
        fullname_max = 0
        state_max = 0
        host_dict = {}
        for hostinfo in self.incus_ls_json():
            host_dict[hostinfo['name']] = hostinfo
        for name, fullname, info in self.name_iter(self.use_all):
            hostinfo = host_dict.get(fullname, None)
            if hostinfo is None:
                state = "NOTCREATED"
            else:
                state = hostinfo['config']['volatile.last_state.power']
            state_dict[fullname] = state
            fullname_len = len(fullname)
            if fullname_len > fullname_max:
                fullname_max = fullname_len
            state_len = len(state)
            if state_len > state_max:
                state_max = state_len
        for fullname, state in state_dict.items():
            print(f'{fullname:<{fullname_max}}  {state:<{fullname_max}}')

    def cmd_shell(self):
        for name, fullname, info in self.name_iter(False):
            self.incus_wait_for_wakeup(fullname, info)
            args = [self.incus_command, 'exec', fullname]
            env = self.get_env(fullname)
            envkeys = []
            if env is not None:
                for k, v in env.items():
                    env_str = f'{k}={v}'
                    args += ['--env', env_str]
                    envkeys += [k]
            args += ['--']
            if not self.user_is_root:
                args += ['sudo', '-i', '-u', self.conf('/config/user')]
                if len(envkeys) > 0:
                    envkeys_str = ','.join(envkeys)
                    args += [f'--preserve-env={envkeys_str}']
            args += ['bash']
            self.logger.debug(pformat(args))
            proc = subprocess.Popen(
                args, shell=False, close_fds=True,
                stdin=None, stdout=None, stderr=None)
            proc.wait()
            break

    def cmd_exec(self):
        for name, fullname, info in self.name_iter(self.use_all):
            self.incus_exec(fullname, self.opt['<args>'],
                            user_is_root=self.user_is_root)

    def incus_launch(self, info, name, fullname):
        image = info['image']
        args = ['launch', image, fullname]
        for p in info.get('profile', {}):
            args += ['-p', self.project_prefix + p]
        for devname, params in info.get('devices', {}).items():
            kvlist = [devname]
            for key, val in params.items():
                kvlist.append(key + '=' + str(val))
            val = ','.join(kvlist)
            args += ['-d', val]

        # NOT WORK: Error: Cannot override config for device "VOLUME_0":
        # Device not found in profile devices
        #
        # volume_list = info.get('volume', None)
        # if volume_list is not None:
        #     # /host|buildimage/NAME/volume : SRC:DST
        #     #   -> -d DEVNAME,type=disk,source=SRC,path=DST
        #     count = 0
        #     for volume_map in volume_list:
        #         device_name = f'VOLUME_{count}'
        #         kvlist = [device_name]
        #         v = volume_map.split(':')  # TODO support "SRC":"DST" ?
        #         src = self.convert_fullpath(v[0])
        #         dst = v[1]
        #         val = f'{device_name},type=disk,source={src},path={dst}'
        #         args += ['-d', val]
        #         count += 1

        for key, val in info.get('config', {}).items():
            args += ['-c', key + '=' + str(val)]
        idmap = self.conf('/config/idmap')
        idmap_uid = None
        self.logger.debug(f'idmap={idmap}')
        if str(idmap).isdigit():
            idmap_uid = str(idmap)
        elif self.tobool(idmap):
            idmap_uid = str(os.getuid())
        container_uid = self.conf('/config/uid')
        if idmap_uid is not None:
            args += ['-c', f'raw.idmap=both {idmap_uid} {container_uid}']

        if self.tobool(info['vm']):
            args += ['--vm']
        else:  # container
            args += ['-c', 'security.nesting=true']
        self.incus(args)

    def mount_volume(self, fullname, info):
        volume_list = info.get('volume', None)
        if volume_list is None:
            return
        # /host|buildimage/NAME/volume : SRC:DST
        #   -> -d DEVNAME,type=disk,source=SRC,path=DST
        count = 0
        for volume_map in volume_list:
            device_name = f'VOLUME_{count}'
            v = volume_map.split(':')  # TODO support "SRC":"DST" ?
            src = self.convert_fullpath(v[0])
            dst = v[1]
            self.incus(['config', 'device', 'add', fullname,
                        device_name, 'disk', f'source={src}', f'path={dst}'])
            count += 1

    def growpart(self, fullname):
        self.incus_exec(fullname,
                        'yum install -y e2fsprogs cloud-utils-growpart gdisk')
        mount = self.incus_exec(fullname, 'mount', output=True)
        device = None
        for line in mount.splitlines():
            fields = line.strip().split()
            if len(fields) >= 3 and fields[2] == "/":
                device = fields[0]
                break
        if device is not None:
            prefix = device.rstrip('0123456789')
            suffix = device[len(prefix):]
            self.incus_exec(fullname, f'growpart {prefix} {suffix}',
                            ignore_error=True)
            self.incus_exec(fullname, f'resize2fs {device}',
                            ignore_error=True)
            self.incus_exec(fullname, 'df -h')

    def install_ssh(self, info, name, fullname):
        self.incus_exec(fullname, f'hostnamectl set-hostname {name}')
        self.incus_exec(fullname, 'systemctl restart systemd-hostnamed')
        if info['series'] == 'rhel':
            self.incus_exec(fullname, 'yum install -y openssh-server')
            self.incus_exec(fullname, 'systemctl enable sshd')
            self.incus_exec(fullname, 'systemctl restart sshd')
        elif info['series'] == 'debian':
            self.incus_exec(fullname, 'apt-get update')
            self.incus_exec(fullname, 'apt-get install -y openssh-server')
            self.incus_exec(fullname, 'systemctl enable ssh')
            self.incus_exec(fullname, 'systemctl restart ssh')

    def setup_user(self, info, fullname):
        user = self.conf('/config/user')
        uid = self.conf('/config/uid')
        # ignore: useradd: user 'incus' already exists
        self.incus_exec(fullname, 'useradd --create-home --shell /bin/bash'
                        + f' --uid {uid} {user}', ignore_error=True)
        homedir = self.incus_exec(fullname,
                                  ['su', user, 'sh', '-c',
                                   'echo $HOME'],
                                  output=True).strip()
        # sshdir=f'/home/{user}/.ssh'
        sshdir = homedir + '/.ssh'
        self.incus_exec(fullname, f'mkdir -p {sshdir}')
        # file copy
        self.incus(['file', 'push', self.authorized_keys,
                    fullname + sshdir + '/authorized_keys'])
        self.incus_exec(fullname, f'chown -R {user}:{user} {sshdir}')
        self.incus_exec(fullname, f'chmod 700 {sshdir}')
        self.incus_exec(fullname, f'chmod 600 {sshdir}/authorized_keys')

        # if info['series'] == 'rhel':
        #     self.incus_exec(fullname, f'usermod -a -G wheel {user}')
        #     self.incus_exec(
        #         fullname,
        #         ['sed', '-i',
        #          '-e', '/%wheel[ \t]\\+ALL=(ALL)[ \t]\\+ALL/s/^/# /',
        #          '-e', '/%wheel[ \t]\\+ALL=(ALL)[ \t]\\+NOPASSWD:/s/^# //',
        #          '/etc/sudoers'])
        # elif info['series'] == 'debian':
        #     self.incus_exec(fullname, f'usermod -a -G sudo {user}')
        #     str_input = StringIO('%sudo   ALL=(ALL:ALL)  NOPASSWD: ALL')
        #     self.incus_exec(fullname, 'tee /etc/sudoers.d/group-sudo',
        #                     input=str_input, output=False)
        #     self.incus_exec(fullname, 'chmod 600 /etc/sudoers.d/group-sudo')
        sudoers = f'/etc/sudoers.d/{user}'
        str_input = StringIO(f'{user}   ALL=(ALL:ALL)  NOPASSWD: ALL')
        self.incus_exec(fullname, f'tee {sudoers}',
                        input=str_input, output=False)
        self.incus_exec(fullname, f'chmod 600 {sudoers}')

    def netconf_rhel(self, fullname, ifname, param, info):
        ipv4_address = param.get('ipv4.address')
        if ipv4_address is None:
            self.logger.debug(f'{ifname}: no static ipv4.address')
            return  # disabled ... not configure
        ipv4_gateway = param.get('ipv4.gateway')
        dns_list = param.get('dns')
        if dns_list is not None:
            dns = ','.join(dns_list)
        else:
            dns = None
        real_ifname = self.convert_net_if(ifname, info)

        lines = self.incus_exec(fullname,
                                'nmcli --fields UUID,DEVICE connection show',
                                output=True)
        uuid = None
        for line in lines.splitlines():
            self.logger.debug(f'nmcli outpuit: {line}')
            fields = line.strip().split()
            if fields[1] == real_ifname:
                uuid = fields[0]
        if uuid is None:
            self.logger.warning('cannot set static IP address')
            return

        # DO NOT add new connection
        # self.incus_exec(fullname,
        #                 'nmcli connection add type ethernet con-name'
        #         + f' {ifname} ifname {real_ifname}')
        self.incus_exec(fullname,
                        f'nmcli connection modify {uuid}'
                        + f' ipv4.method manual ipv4.addr {ipv4_address}')
        if ipv4_gateway is not None:
            self.incus_exec(fullname, 'nmcli connection modify '
                            + f'{uuid} ipv4.gateway {ipv4_gateway}')
        if dns is not None:
            self.incus_exec(fullname, 'nmcli connection modify'
                            + f' {uuid} ipv4.dns "{dns}"')

    def netconf_debian(self, fullname, ifname, param, info, netplan_dict):
        ipv4_address = param.get('ipv4.address')
        ipv4_gateway = param.get('ipv4.gateway')
        dns_list = param.get('dns')
        real_ifname = self.convert_net_if(ifname, info)

        if ipv4_address is not None:
            new_yaml = f'''network:
  version: 2
  ethernets:
    {real_ifname}:
      addresses:
        - {ipv4_address}
      dhcp4: false
      dhcp6: false
      accept-ra: false
      link-local: []
'''
            new_dict = yaml.safe_load(new_yaml)
            d2 = new_dict['network']['ethernets'][real_ifname]
            if ipv4_gateway is not None:
                d2['routes'] = [{'to': 'default', 'via': ipv4_gateway}]
            if dns_list is not None:
                d2['nameservers'] = {'addresses': dns_list}
        else:
            new_yaml = f'''network:
  version: 2
  ethernets:
    {real_ifname}:
      dhcp4: true
      dhcp6: true
'''
            new_dict = yaml.safe_load(new_yaml)
        self.deep_update(netplan_dict, new_dict, override=True)

    def setup_network_static(self, info, fullname):
        # configure static IP address
        netstatic = info.get('network-static', None)
        if netstatic is None:
            return

        if info['series'] == 'rhel':
            self.incus_exec(fullname, 'yum install -y NetworkManager')
            self.incus_exec(fullname, 'systemctl enable NetworkManager')
            self.incus_exec(fullname, 'systemctl restart NetworkManager')
            for ifname, param in netstatic.items():
                self.netconf_rhel(fullname, ifname, param, info)
            self.incus_exec(fullname, 'systemctl restart NetworkManager')
        elif info['series'] == 'debian':
            netplan_dict = {
                # 'network': {
                #     'version': 2,
                #     'ethernets': {},
                # }
            }
            for ifname, param in netstatic.items():
                self.logger.debug(f'{fullname} {ifname} {str(param)}')
                self.netconf_debian(fullname, ifname, param,
                                    info, netplan_dict)
            netplan_path = '/etc/netplan/50-incus.yaml'
            self.incus_exec(fullname, f'touch {netplan_path}')
            self.incus_exec(fullname, f'chmod 600 {netplan_path}')
            str_input = StringIO(yaml.dump(netplan_dict, sort_keys=False))
            self.incus_exec(fullname, f'tee {netplan_path}', input=str_input)
            self.incus_exec(fullname, 'netplan apply')

    def update_etchosts(self, info, fullname):
        if not self.tobool(self.conf('/config/etchosts', default=True)):
            return  # disabled
        # backup and restore
        self.incus_exec(fullname, 'cp -n /etc/hosts /etc/hosts.orig')
        self.incus_exec(fullname, 'cp -f /etc/hosts.orig /etc/hosts')
        etchosts = self.gen_etchosts()
        etchosts_str = '\n' + '\n'.join(etchosts) + '\n'
        self.incus_exec(fullname, 'tee -a /etc/hosts',
                        input=etchosts_str, output=False)

    def create_block_device(self, info, name, fullname):
        bd = info.get('block-device', None)
        if bd is None:
            return
        for bdname, params in bd.items():
            pool = params['pool']  # MUST
            size = params['size']  # MUST
            if self.tobool(params.get('create', False)):  # default: False
                self.incus(f'storage volume delete {pool} {bdname}',
                           ignore_error=True)
                self.incus(f'storage volume create {pool} {bdname} '
                           + f'size={size} --type=block')
            self.incus(f'storage volume attach {pool} {bdname} {fullname}')

    def launch_common(self):
        for name, fullname, info in self.name_iter(self.use_all):
            if self.control_buildimage:
                # check required values (MUST)
                info['series']
            self.incus_launch(info, name, fullname)
            self.create_block_device(info, name, fullname)

        for name, fullname, info in self.name_iter(self.use_all):
            self.incus_wait_for_wakeup(fullname, info)
            self.setup_network_static(info, fullname)
            self.incus(f'stop {fullname}')
            self.mount_volume(fullname, info)
            self.incus(f'start {fullname}')

        for name, fullname, info in self.name_iter(self.use_all):
            self.incus_wait_for_wakeup(fullname, info)
            if self.tobool(info['vm']) and info['series'] == 'rhel':
                # growpart for rhel VM
                self.growpart(fullname)
            self.setup_user(info, fullname)
            if not self.control_buildimage:
                self.install_ssh(info, name, fullname)
                self.update_etchosts(info, fullname)

            # run /host|buildimage/NAME/setup
            for cmd in info.get('setup', []):
                if cmd == '__RESTART__':
                    self.incus(f'restart {fullname}')
                    self.incus_wait_for_wakeup(fullname, info)
                else:
                    self.incus_exec(fullname, cmd, user_is_root=False)

            if self.control_buildimage:
                # publish buildimage
                aliases = info.get('publish-alias', None)
                if aliases is not None:
                    remotes = info.get('publish-remote', None)
                    self.incus(f'stop {fullname}')

                    def publish(remote):
                        args = ['publish', fullname]
                        if remote is not None:
                            args.append(remote + ':')
                        for alias in aliases:
                            full_alias = self.project_prefix + alias
                            self.incus(['image', 'delete', full_alias],
                                       ignore_error=True)
                            args.extend(['--alias', full_alias])
                        self.incus(args)

                    if remotes is None:
                        publish(None)
                    else:
                        for remote in remotes:
                            publish(remote)

    def cmd_build(self):
        self.control_buildimage = True
        self.cmd_stop()
        self.cmd_delete()
        self.launch_common()

    def cmd_launch(self):
        self.control_buildimage = False
        self.launch_common()


if __name__ == '__main__':
    IncusAuto(program_name).main()
